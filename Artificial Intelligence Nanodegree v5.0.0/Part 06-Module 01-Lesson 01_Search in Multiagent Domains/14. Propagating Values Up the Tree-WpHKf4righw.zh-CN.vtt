WEBVTT
Kind: captions
Language: zh-CN

00:00:00.310 --> 00:00:03.976
为了将博弈树的胜败信息向上传递

00:00:03.976 --> 00:00:07.963
到计算机玩家能进行决策的那个点 我们得从博弈树底部开始传递信息

00:00:07.963 --> 00:00:10.375
先从博弈树左边开始

00:00:10.375 --> 00:00:12.667
在最左边的分支上 O 赢了

00:00:12.667 --> 00:00:14.999
旁边的分支

00:00:14.999 --> 00:00:18.419
O 永远走不到棋盘最后的空格上 所以输了

00:00:18.420 --> 00:00:21.130
由于对手 X 玩游戏就是为了赢

00:00:21.129 --> 00:00:25.570
它会最小化 X 的分数 所以 X 永远不会选最左边的分支

00:00:25.570 --> 00:00:27.657
而会选择这一分支

00:00:27.657 --> 00:00:31.083
让计算机玩家得到 -1 分

00:00:31.083 --> 00:00:34.467
但是计算机玩家可以避免这个情况

00:00:34.468 --> 00:00:36.805
只要它在上一层作出更明智的选择即可

00:00:36.804 --> 00:00:41.509
这两个分支都能赢 都能得到 +1 分

00:00:41.509 --> 00:00:45.509
我们可以继续向博弈树上头传递这些分数 在  min 和

00:00:45.509 --> 00:00:48.149
max  层间不断交替 直到抵达顶端

00:00:48.149 --> 00:00:50.420
这个为每个节点计算分值的过程

00:00:50.420 --> 00:00:53.649
也就是这个从下到上的过程 就称为极大极小值算法

00:00:53.649 --> 00:00:58.171
在每个 max 节点上 你都要在其子节点中选一个最大值

00:00:58.171 --> 00:01:03.159
如果 +1 的子节点至少有一个 计算机就总会选那些 +1 的 以便赢得游戏

00:01:03.159 --> 00:01:07.319
否则 假设对手完美 从选错的节点开始 计算机永远也不可能赢得棋局

00:01:07.319 --> 00:01:12.741
当然 作为对手 在每个 min 节点上 我们都会选择最小值

