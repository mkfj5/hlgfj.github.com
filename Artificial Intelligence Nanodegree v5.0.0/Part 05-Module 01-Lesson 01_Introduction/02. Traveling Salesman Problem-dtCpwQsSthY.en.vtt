WEBVTT
Kind: captions
Language: en

00:00:00.190 --> 00:00:02.800
You've heard me say,
do the stupid thing first and

00:00:02.800 --> 00:00:05.180
only add intelligence when necessary.

00:00:05.180 --> 00:00:08.080
It turns out that there
are a whole class of problems

00:00:08.080 --> 00:00:10.240
where just adding a little
bit of intelligence and

00:00:10.240 --> 00:00:14.840
iteratively improving the solution gets
you very close to an optimal solution.

00:00:14.840 --> 00:00:16.200
&gt;&gt; Like what?

00:00:16.200 --> 00:00:19.700
&gt;&gt; One of the classic ones is
the traveling salesman problem.

00:00:19.700 --> 00:00:21.280
Imagine you're a salesman.

00:00:21.280 --> 00:00:22.220
&gt;&gt; That might be nice.

00:00:22.220 --> 00:00:24.350
I'd probably make more money
than what you're paying me.

00:00:24.350 --> 00:00:27.834
[SOUND] As I was saying,
imagine you're a salesman and

00:00:27.834 --> 00:00:30.400
you have five cities you want to visit.

00:00:30.400 --> 00:00:31.917
You can start in any city, but

00:00:31.917 --> 00:00:34.685
you have to fly to all of them
before your tour is over.

00:00:34.685 --> 00:00:38.460
And you have to come back to
the starting city in the end.

00:00:38.460 --> 00:00:41.480
What is the most efficient order
of flights to minimize overall

00:00:41.480 --> 00:00:42.700
distance flown.

00:00:42.700 --> 00:00:44.660
This problem sounds NP hard.

00:00:44.660 --> 00:00:45.757
&gt;&gt; What do you mean?

00:00:45.757 --> 00:00:49.900
&gt;&gt; Well, NP actually means
non-deterministic polynomial time.

00:00:49.900 --> 00:00:53.320
But people commonly talk about
non-polynomial algorithm as all being

00:00:53.320 --> 00:00:55.800
about as hard as each other or NP hard.

00:00:55.800 --> 00:00:58.540
This problem seems exponentially
difficult in the number of cities

00:00:58.540 --> 00:01:02.520
considered and so it seems just as bad
as our game playing or search problems.

00:01:02.520 --> 00:01:03.350
&gt;&gt; Precisely.

00:01:03.350 --> 00:01:05.069
But like with our other problems,

00:01:05.069 --> 00:01:08.820
we're going to figure out tricks to
help solve the problem efficiently.

00:01:08.820 --> 00:01:11.180
First we're going to connect
the cities randomly.

00:01:11.180 --> 00:01:12.410
&gt;&gt; How about like this?

00:01:12.410 --> 00:01:13.200
&gt;&gt; Great.

00:01:13.200 --> 00:01:16.210
Next we are going to look at any
place where the paths cross.

00:01:16.210 --> 00:01:18.210
We'll show them in red here.

00:01:18.210 --> 00:01:18.810
&gt;&gt; I get it.

00:01:18.810 --> 00:01:21.810
We need to revise the figure
to uncross each situation.

00:01:21.810 --> 00:01:23.595
That should reduce
the distance traveled.

00:01:23.595 --> 00:01:27.935
&gt;&gt; Yep, and for large problems we can
do the process iteratively until there

00:01:27.935 --> 00:01:29.680
are no crossed paths.

00:01:29.680 --> 00:01:32.800
You can do this simple process
with thousands of cities and

00:01:32.800 --> 00:01:36.200
get a result that is within
1% of the optimal solution.

00:01:36.200 --> 00:01:37.620
&gt;&gt; But that seems like a hack.

00:01:37.620 --> 00:01:39.430
How does this technique generalize?

00:01:39.430 --> 00:01:43.170
&gt;&gt; That is the subject of this section,
it will improve in algorithms.

00:01:43.170 --> 00:01:44.940
Let's start out with
our challenge question.
最新课程跟课件还有一对一辅导请加wx：udacity6

