WEBVTT
Kind: captions
Language: zh-CN

00:00:00.190 --> 00:00:01.240
你也听我说过

00:00:01.240 --> 00:00:05.179
先用笨办法 必要时才用智能

00:00:05.179 --> 00:00:08.080
而就有这么一整类问题

00:00:08.080 --> 00:00:10.240
只需动用一点智能

00:00:10.240 --> 00:00:14.839
对解进行迭代改进 就能十分接近最优解

00:00:14.839 --> 00:00:16.199
比如说？

00:00:16.199 --> 00:00:19.699
最典型的问题之一是旅行商问题

00:00:19.699 --> 00:00:21.280
想象你是个销售员

00:00:21.280 --> 00:00:22.220
那可能会很不错

00:00:22.219 --> 00:00:24.179
当销售员赚的钱应该比你给的多

00:00:25.780 --> 00:00:26.880
[咳嗽] 正如我所说

00:00:26.879 --> 00:00:30.500
想象你是个销售员 你想前往五座城市

00:00:30.500 --> 00:00:32.189
你可以从任意城市出发

00:00:32.189 --> 00:00:35.280
但在这趟旅途里 每座城市你都得去一趟

00:00:35.280 --> 00:00:38.484
最后还得飞回起始城市

00:00:38.484 --> 00:00:41.479
那么要最小化总飞行距离

00:00:41.479 --> 00:00:42.699
航班得怎么排序才最高效呢？

00:00:42.700 --> 00:00:44.660
这听起来像 NP-hard 问题

00:00:44.659 --> 00:00:45.819
什么意思？

00:00:45.820 --> 00:00:49.899
NP 问题就是指非确定多项式时间问题

00:00:49.899 --> 00:00:53.320
不过人们通常都说非多项式算法都差不多难

00:00:53.320 --> 00:00:55.799
所以就简称为 NP-hard 问题了

00:00:55.799 --> 00:00:58.539
这个问题需要考虑的城市数似乎有指数爆炸的危险

00:00:58.539 --> 00:01:02.519
所以听着和博弈或搜索问题一样难

00:01:02.520 --> 00:01:05.069
的确 但就像对付其它问题一样

00:01:05.069 --> 00:01:08.820
我们也要找出办法来高效解决这个问题

00:01:08.819 --> 00:01:11.179
首先 我们随机连接这些城市

00:01:11.180 --> 00:01:12.410
比如这样？

00:01:12.409 --> 00:01:13.200
不错！

00:01:13.200 --> 00:01:16.210
接着 我们来看那些路径交叉的城市

00:01:16.209 --> 00:01:18.256
用红线显示

00:01:18.256 --> 00:01:18.810
我懂了

00:01:18.810 --> 00:01:21.810
我们要修改值 不让路径交叉

00:01:21.810 --> 00:01:23.700
这样应该就能减小旅行距离了

00:01:23.700 --> 00:01:25.340
对的 对于大型问题

00:01:25.340 --> 00:01:29.680
我们可以对这个过程进行迭代 直到不再有路径交叉了

00:01:29.680 --> 00:01:32.800
你可以在数千座城市上应用这个简单的过程

00:01:32.799 --> 00:01:36.200
然后得到一个误差不超过最优解 1% 的结果

00:01:36.200 --> 00:01:37.620
这听着像破解行为啊

00:01:37.620 --> 00:01:39.430
要怎么让这项技术通用起来呢？

00:01:39.430 --> 00:01:43.170
这就是本节的内容了 即迭代改进算法

00:01:43.170 --> 00:01:44.939
我们先来看看挑战问题
最新课程跟课件还有一对一辅导请加wx：udacity6

