WEBVTT
Kind: captions
Language: zh-CN

00:00:00.410 --> 00:00:03.580
接下来我们讨论词汇量增加的问题

00:00:03.580 --> 00:00:07.040
— 好 我已经挑选了一些手势 用来组成短语

00:00:07.040 --> 00:00:10.449
我们要选择每个手势的拓扑图

00:00:10.449 --> 00:00:13.059
— 我们已经为 I 和 we 选择了拓扑图

00:00:13.060 --> 00:00:15.179
接下来你列表中的符号是什么？

00:00:15.179 --> 00:00:16.684
— 我们来添加 want

00:00:16.684 --> 00:00:18.711
[背景音]

00:00:18.711 --> 00:00:20.679
你认为包括几个状态呢？

00:00:20.679 --> 00:00:23.370
— 包括起初你举起手来

00:00:23.370 --> 00:00:23.980
手势本身的实际动作

00:00:23.980 --> 00:00:25.780
然后是你再次放下手

00:00:25.780 --> 00:00:27.100
我认为是三个状态

00:00:27.100 --> 00:00:28.900
— 那么 need 呢？

00:00:28.899 --> 00:00:30.724
[背景音]

00:00:30.725 --> 00:00:33.850
— 这是类似的 所以我也会用三个状态

00:00:33.850 --> 00:00:35.530
— 好 这是个比较复杂的

00:00:35.530 --> 00:00:37.908
这里有个例子是 table (桌子) 手势

00:00:37.908 --> 00:00:39.696
[背景音]

00:00:39.697 --> 00:00:42.530
不过等一下 这个例子不太好

00:00:42.530 --> 00:00:43.950
还有个关于 table (桌子) 更好的例子

00:00:45.939 --> 00:00:47.769
— 那么你双手举起又放下两次？

00:00:47.770 --> 00:00:49.880
这个例子看起来有 4 个状态

00:00:49.880 --> 00:00:53.740
— 没错 不过为了更加有趣 这里还有个例子

00:00:53.740 --> 00:00:55.475
[背景音]

00:00:55.475 --> 00:00:58.230
— 等等 这次你双手举起又放下了三次

00:00:58.229 --> 00:00:59.939
允许出现多少次？

00:00:59.939 --> 00:01:02.539
— 其实你看到动作重复了两次

00:01:02.539 --> 00:01:04.370
但是如果有人认为难以理解

00:01:04.370 --> 00:01:06.730
他们可能会重复动作 拖延时间

00:01:06.730 --> 00:01:10.590
这类似于英语演讲者说 or (呃呃呃)

00:01:10.590 --> 00:01:13.200
— 好 那么我们如何用隐马尔可夫模型解决这个问题呢？

00:01:13.200 --> 00:01:17.130
— 我认为不能总是使用隐马尔可夫模型从左向右处理

00:01:17.129 --> 00:01:17.799
— 好

00:01:17.799 --> 00:01:20.920
我们实际上可以利用隐马尔可夫模型形成循环 例如从状态 3 到 2

00:01:20.920 --> 00:01:24.010
这样可以重复很多次动作

00:01:24.010 --> 00:01:26.000
— 没错 你明白了我的意思

00:01:26.000 --> 00:01:29.140
实际上我们可以尝试许多不同的拓扑图

00:01:29.140 --> 00:01:31.284
使用交叉验证 利用随机选择的

00:01:31.284 --> 00:01:34.289
独立训练的测试集 确定最好的一个

00:01:34.290 --> 00:01:36.990
— 另一个例子 you 首先从简单的开始 策略对吗？

00:01:36.989 --> 00:01:38.839
— 没错 但在这个例子中

00:01:38.840 --> 00:01:42.900
我们首先尝试简单的拓扑图 然后如有必要只添加状态

00:01:42.900 --> 00:01:43.750
我们来看另一个问题

00:01:43.750 --> 00:01:46.350
这个例子 cat

00:01:46.350 --> 00:01:47.289
[背景音]

00:01:47.289 --> 00:01:49.468
这是另一个例子 cat

00:01:49.468 --> 00:01:50.676
[背景音]

00:01:50.676 --> 00:01:53.159
— 一个是单手动作 另一个是双手动作

00:01:53.159 --> 00:01:56.100
我认为利用简单的拓扑图技巧无法解决这个问题

00:01:56.100 --> 00:01:58.608
— 我们可以尝试使用正常三个状态的隐马尔可夫模型

00:01:58.608 --> 00:02:03.109
然后使用混合高斯分布 帮助处理我们得到的概率

00:02:03.109 --> 00:02:05.849
— 但是我认为把这些作为两个不同的手势进行识别

00:02:05.849 --> 00:02:06.469
更合理

00:02:06.469 --> 00:02:07.469
— 怎么做到？

00:02:07.469 --> 00:02:09.960
— 我们可以为手势的第一个变化训练一个模型

00:02:09.960 --> 00:02:11.491
我们命名为 cat 1

00:02:11.491 --> 00:02:14.822
然后为第二个变化训练一个独立的模型 命名为 cat 2

00:02:14.822 --> 00:02:17.120
然后我们识别 cat 1

00:02:17.120 --> 00:02:20.409
或 cat 2 然后输出识别程序 cat

00:02:20.409 --> 00:02:22.359
— 没错 这样应该可以解决问题

00:02:22.360 --> 00:02:25.090
虽然这种方法向词语中添加了更多手势

00:02:25.090 --> 00:02:28.800
实际上得出了更高精确度的结果

00:02:28.800 --> 00:02:31.300
假如我们有足够的样本训练所有变化

