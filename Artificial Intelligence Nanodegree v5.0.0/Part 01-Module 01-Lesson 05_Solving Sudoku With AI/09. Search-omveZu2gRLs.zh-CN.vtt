WEBVTT
Kind: captions
Language: zh-CN

00:00:00.500 --> 00:00:02.049
这是我们的数独问题

00:00:02.049 --> 00:00:05.269
在执行了约束传播后 也就是不断迭代两个函数 排除法和唯一解法

00:00:05.269 --> 00:00:07.809
我们得到了这个结果

00:00:07.809 --> 00:00:11.939
每个格子都写上了可以填进去的值

00:00:11.939 --> 00:00:16.119
我们随机挑一个 就挑这个能填 8 和 9 的吧

00:00:16.120 --> 00:00:17.859
因为我们还不知道要填什么值

00:00:17.859 --> 00:00:19.989
所以我们两个可能性都考虑看看

00:00:19.989 --> 00:00:23.070
假设值为 8 我们来试着解这个数独问题

00:00:24.089 --> 00:00:27.809
再假设值为 9 的情况

00:00:27.809 --> 00:00:31.160
于是我们就建立了概率树

00:00:31.160 --> 00:00:33.119
显然 我们也可以挑其它格子

00:00:33.119 --> 00:00:35.820
并按可能值为其绘制各种情况 但之所以要挑

00:00:35.820 --> 00:00:39.359
只有两个可能值的格子 是因为这样工作量小些

00:00:39.359 --> 00:00:40.320
我们来复习一下

00:00:40.320 --> 00:00:44.570
这是原始数独 格子里有两个可能值

00:00:44.570 --> 00:00:46.740
8 和 9

00:00:46.740 --> 00:00:50.630
我们分别对这两种可能进行约束传播

00:00:50.630 --> 00:00:52.289
假设我们要处理左边的这一个

00:00:52.289 --> 00:00:56.320
在进行了约束传播后 我们发现还是得不出结果

00:00:56.320 --> 00:00:59.359
我们再挑一个可能值最少的格子来看

00:00:59.359 --> 00:01:03.939
假设是这个 有三个可能值 1、5 和 9

00:01:03.939 --> 00:01:06.021
再次将树分支

00:01:06.021 --> 00:01:08.649
试着解用这种办法得到的三个数独问题

00:01:08.649 --> 00:01:12.269
[空白音频]

00:01:12.269 --> 00:01:14.265
假设我们试着解了左边的这个

00:01:14.266 --> 00:01:16.450
仍没有得到最终解

00:01:16.450 --> 00:01:18.840
没事 我们试试旁边这个

00:01:18.840 --> 00:01:20.990
假设这次分成了两个数独分支

00:01:20.989 --> 00:01:24.304
[空白音频]

00:01:24.304 --> 00:01:27.121
再一次 假设左边这个还是没有得到最终解

00:01:27.120 --> 00:01:28.799
但右边的这个得到了

00:01:28.799 --> 00:01:30.879
太棒了 我们得到一个解了

00:01:30.879 --> 00:01:33.959
这就是解数独的大致过程了 如果我们解不出数独

00:01:33.959 --> 00:01:37.199
而是得到一些格子的可能值 那我们就进行分支

00:01:37.200 --> 00:01:39.109
试着解分支上的数独

00:01:40.230 --> 00:01:44.060
如果分支无解 那就试试另一个

00:01:44.060 --> 00:01:46.530
循环往复 直到得到解为止

00:01:46.530 --> 00:01:49.210
这个过程就叫做深度优先搜索

00:01:50.959 --> 00:01:53.599
深度优先搜索算法工作原理如下

00:01:53.599 --> 00:01:57.669
从根开始 总是从树的最左边走起

00:01:57.670 --> 00:02:02.180
一旦走到尽头 就向右走向旁边的分支 以此类推

00:02:02.180 --> 00:02:05.450
你可以在纳米学位课程之后的内容里进一步学习该算法.最新课程跟课件还有一对一辅导请加wx：udacity6

