WEBVTT
Kind: captions
Language: zh-CN

00:00:00.560 --> 00:00:03.790
我们已经学习了如何在信度网络中利用列举法

00:00:03.790 --> 00:00:04.929
解决推理问题

00:00:04.929 --> 00:00:07.910
对于闹钟网络的简单网络而言 这就是我们需要了解的全部内容

00:00:07.910 --> 00:00:09.440
这里只有 5 个变量

00:00:09.441 --> 00:00:12.114
即使 5 个变量都是隐变量

00:00:12.114 --> 00:00:15.690
表格中只有 32 行需要求和

00:00:15.689 --> 00:00:17.780
从理论角度来讲 我们已经完成了

00:00:17.780 --> 00:00:21.289
但是从实际角度来讲 其他网络会很麻烦

00:00:21.289 --> 00:00:27.006
观察这个用于确定车主购买保险的网络

00:00:27.006 --> 00:00:29.140
这里有 27 个不同的变量

00:00:29.140 --> 00:00:31.437
如果每个变量都是布尔数据类型

00:00:31.437 --> 00:00:34.648
我们会需要对 1 亿多行求和

00:00:34.648 --> 00:00:39.190
实际上一些变量不是布尔数据类型 而是多个值

00:00:39.189 --> 00:00:42.519
实际上为了展现整个网络

00:00:42.520 --> 00:00:47.480
进行列举  我们要对 1000 的五次幂进行求和

00:00:47.479 --> 00:00:49.029
这并不现实

00:00:49.030 --> 00:00:52.750
所以我们提出一些方法 远远快于

00:00:52.750 --> 00:00:53.509
列举一切内容

00:00:53.509 --> 00:00:57.982
我们在贝叶斯网络中加快推理速度所使用的第一种技巧

00:00:57.982 --> 00:01:00.930
是从列举中提取项

00:01:00.930 --> 00:01:05.746
例如这里 对于 e 和 a 所有值

00:01:05.746 --> 00:01:07.310
P(+b) 都是相同的

00:01:07.310 --> 00:01:10.799
所以我们提取这一项 移到求和公式外面

00:01:10.799 --> 00:01:12.450
这样我们的工作量会少一些

00:01:12.450 --> 00:01:16.870
不是让这一项出现在每一行 而是乘以这一项

00:01:16.870 --> 00:01:21.272
我们也可以移出这一项 P(e) 放在求和公式的左侧

00:01:21.272 --> 00:01:23.265
因为它不依赖于 a

00:01:23.265 --> 00:01:24.858
通过这样做我们可以减轻工作量

00:01:24.858 --> 00:01:29.909
现在求和的内循环只剩下三项 而不是五项

00:01:29.909 --> 00:01:34.019
我们减少了表格每一行的成本

00:01:34.019 --> 00:01:36.689
但是还包含表格中行数的相同数量

00:01:36.689 --> 00:01:38.569
我们还可以继续优化

00:01:38.569 --> 00:01:39.609
接下来有效推理的技巧是

00:01:39.609 --> 00:01:44.239
最大化变量的独立性

00:01:44.239 --> 00:01:47.159
贝叶斯网络的结构决定了它

00:01:47.159 --> 00:01:48.269
进行推理的效率

00:01:48.269 --> 00:01:53.188
例如线性字符串变量 X1 到 Xn

00:01:53.188 --> 00:01:58.739
可以根据 n 的比例 O(n) 进行推理

00:01:58.739 --> 00:02:02.184
虽然这个网络是完整的

00:02:02.185 --> 00:02:06.055
每个节点指向另一个节点

00:02:06.055 --> 00:02:10.977
如果变量 n 是布尔数据类型 那么得到 2 的 n 次方

00:02:10.977 --> 00:02:14.082
在之前我们见到的闹钟网络中

00:02:14.082 --> 00:02:18.546
我们务必保证得到了

00:02:18.546 --> 00:02:21.668
网络结构中展现的所有独立关系

00:02:21.668 --> 00:02:24.391
但是如果把这些节点以不同顺序放置

00:02:24.390 --> 00:02:26.810
我们最后会得到不同的结构

00:02:26.810 --> 00:02:31.270
我们首先把约翰打电话放在第一个节点

00:02:31.270 --> 00:02:34.230
然后增加节点玛丽打电话

00:02:34.229 --> 00:02:38.709
那么问题是 在这两个节点的情况下 观察玛丽打电话的节点

00:02:38.710 --> 00:02:44.719
与约翰打电话的节点是相互依赖还是相互独立？

