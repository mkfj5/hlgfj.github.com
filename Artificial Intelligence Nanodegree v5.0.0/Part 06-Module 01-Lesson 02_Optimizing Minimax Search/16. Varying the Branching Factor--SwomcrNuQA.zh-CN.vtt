WEBVTT
Kind: captions
Language: zh-CN

00:00:00.340 --> 00:00:02.869
所以 基本上你是说迭代加深几乎没有什么负担

00:00:02.870 --> 00:00:05.360
因为问题涉及指数增长？

00:00:05.360 --> 00:00:06.370
对的

00:00:06.370 --> 00:00:09.039
那我打赌迭代加深真的很实用 如果你遇到的游戏是像

00:00:09.039 --> 00:00:11.719
孤立棋这样的 具备大不相同的分枝因子

00:00:11.720 --> 00:00:12.730
怎么说？

00:00:12.730 --> 00:00:15.679
我们之前计算出最多只能搜索到第九层那么深

00:00:15.679 --> 00:00:19.120
如果孤立棋盘是五乘五的话 这样方能在两秒内返回出结果

00:00:19.120 --> 00:00:21.440
我们当时假设的分枝因子是 8

00:00:21.440 --> 00:00:24.839
但是到了终局 孤立棋玩家就只剩几步可走了

00:00:24.839 --> 00:00:27.910
所以在终局的时候 或许我们可以搜索得深许多

00:00:27.910 --> 00:00:30.890
而且终局往往就是

00:00:30.890 --> 00:00:34.520
你想搜索得更深的时候 因为你想知道结果会怎么样

00:00:34.520 --> 00:00:36.460
另一方面 在开局的时候

00:00:36.460 --> 00:00:37.850
分枝因子很大

00:00:37.850 --> 00:00:40.340
计算机玩家可能无法在两秒内返回出结果

00:00:40.340 --> 00:00:44.140
对的 迭代加深意味着计算机玩家

00:00:44.140 --> 00:00:47.100
随时可以给出答案 而不怕耗尽时间

00:00:47.100 --> 00:00:51.460
而且它能够在有限时间内尽可能深地搜索

00:00:51.460 --> 00:00:53.765
我们将每次下子的时间都限制在两秒内

00:00:53.765 --> 00:00:57.439
然而有些游戏 如快棋赛

00:00:57.439 --> 00:01:01.599
我们会限制玩家全程可以玩的时间

00:01:01.600 --> 00:01:05.659
在那种情况下 计算机玩家有时想搜索得更深些

00:01:05.659 --> 00:01:08.399
有时则浅些

00:01:09.709 --> 00:01:13.379
所以我们通常可以制定一个策略 从而判断我们想搜索的深度

00:01:13.379 --> 00:01:16.092
比如建立开局库 记录开局的标准起步

00:01:16.093 --> 00:01:18.909
然后在对局中途搜索得更深些

00:01:18.909 --> 00:01:22.471
终局则少用些时间 这都取决于分枝因子的减少幅度

00:01:22.471 --> 00:01:25.873
然后仍用迭代加深 让计算机玩家得以搜索到终局

00:01:25.873 --> 00:01:29.000
或是在剩余时间里搜索得尽可能深

00:01:29.000 --> 00:01:32.091
或许我们想为每一步

00:01:32.091 --> 00:01:34.918
分配保险的用时 然后用迭代加深和

00:01:34.918 --> 00:01:39.099
静止搜索来决定哪几步需要额外耗时

00:01:40.420 --> 00:01:42.620
这些都是很好的策略

00:01:42.620 --> 00:01:45.670
但我们还是会遇到一个麻烦 即水平效应

