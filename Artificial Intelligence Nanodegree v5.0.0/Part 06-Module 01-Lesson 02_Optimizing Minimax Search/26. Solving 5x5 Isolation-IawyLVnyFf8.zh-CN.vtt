WEBVTT
Kind: captions
Language: zh-CN

00:00:00.370 --> 00:00:04.830
我要向大家介绍一位特邀嘉宾学员 他是 Malcolm Haynes 来自之前的课程

00:00:04.830 --> 00:00:05.710
嗨 Malcolm

00:00:05.710 --> 00:00:06.929
嗨 Thad

00:00:06.929 --> 00:00:10.539
你在课堂里处理 5 乘 5 孤立棋时

00:00:10.539 --> 00:00:12.750
认为自己找到了办法 可以搜索到终局

00:00:12.750 --> 00:00:14.109
对的

00:00:14.109 --> 00:00:17.570
但我们之前在讲分枝因子的时候 我们说过

00:00:17.570 --> 00:00:21.100
要在合理时间内搜索到终局是不可能的

00:00:21.100 --> 00:00:22.920
你是怎么做到的呢？

00:00:22.920 --> 00:00:27.480
首先 我应用了极大极小值算法和 alpha-beta 剪枝算法

00:00:27.480 --> 00:00:32.079
你也知道 这能够减小搜索要耗费的空间 从 b^d

00:00:32.079 --> 00:00:33.559
减为 b^d/2

00:00:33.560 --> 00:00:37.340
因此 搜索空间大概从 8^25 减小成 8^12

00:00:38.600 --> 00:00:42.390
接着 我意识到有些走法是等同的

00:00:42.390 --> 00:00:44.969
比如 我们来看看玩家甲的起步

00:00:47.130 --> 00:00:52.179
如果玩家甲走到 (0,0) 那就相当于走到 (4,0)

00:00:52.179 --> 00:00:54.731
你可以把棋盘旋转 90 度

00:00:54.731 --> 00:00:56.317
就能发现两者是同样的

00:00:56.317 --> 00:01:01.127
因此 知道了起步为 (0,0) 的博弈树

00:01:01.127 --> 00:01:04.894
也就知道了起步为 (4,0) 的博弈树了

00:01:04.894 --> 00:01:08.684
同理 (4,4) 和 (0,4) 也一样

00:01:08.683 --> 00:01:11.492
这很实用 特别是在游戏刚开局的时候

00:01:11.492 --> 00:01:14.079
那个时候分枝因子还很大

00:01:14.079 --> 00:01:19.250
比如 虽然玩家甲有 25 种可能走法 但在现实中

00:01:19.250 --> 00:01:21.659
不一样的走法只有 6 种

00:01:21.659 --> 00:01:25.979
这是水平对称、垂直对称

00:01:25.980 --> 00:01:30.579
和对角线对称造成的 当然 还要加上中央那个走法

00:01:30.579 --> 00:01:34.510
刚才说的就是玩家甲六种不同起步 以及效果相当的走法

00:01:35.510 --> 00:01:37.359
其它棋局

00:01:37.359 --> 00:01:41.750
也可采用相似的分析 只要棋局里包含一系列有规律的走法即可

00:01:43.409 --> 00:01:44.489
我们来看一个例子

00:01:45.549 --> 00:01:48.659
在这个例子中 O 移动到了 [(2,2)]

00:01:48.659 --> 00:01:50.439
然后轮到 X

00:01:50.439 --> 00:01:54.789
X 开始考虑可能的走法 它先评估了朝 [(2,1)] 移动的走法

00:01:54.790 --> 00:01:58.540
于是知道了棋局 [(2,2) , (2,1)] 的分值

00:01:58.540 --> 00:02:01.720
现在让 X 考虑走向 [(2,3)]

00:02:01.719 --> 00:02:05.379
X 会检查这一步的结果是否已知

00:02:05.379 --> 00:02:09.020
为了做到这一点 X 会检查自己是否已经知道棋局

00:02:09.020 --> 00:02:10.709
[(2,2) , (2,3)] 的值

00:02:10.710 --> 00:02:11.770
它不知道

00:02:11.770 --> 00:02:14.620
接着 X 将棋盘旋转 90 度

00:02:14.620 --> 00:02:18.218
检查自己是否知道 [(2,2) , (1,2)] 的值

00:02:18.218 --> 00:02:19.317
它不知道

00:02:19.318 --> 00:02:21.939
再接着 X 将棋盘旋转 180 度

00:02:21.939 --> 00:02:27.121
检查自己是否知道 [(2,2) , (2,1)] 的值

00:02:27.121 --> 00:02:29.300
啊哈 它知道的

00:02:29.300 --> 00:02:32.462
于是 X 返回出棋局 [(2,2) , (2,1)] 的值

00:02:32.461 --> 00:02:35.289
而无需进一步扩展博弈树

00:02:35.289 --> 00:02:36.739
如果 X 找不到解

00:02:36.740 --> 00:02:39.560
它就会将棋盘旋转 207 度 再将棋盘沿着对角线翻转

00:02:39.560 --> 00:02:43.740
轮流检查这两个棋局

00:02:44.939 --> 00:02:47.669
若还未找到解 X 才需要扩展博弈树

00:02:47.669 --> 00:02:50.469
所以你发现对称能够有效减少

00:02:50.469 --> 00:02:52.270
需要扩展的节点数

00:02:52.270 --> 00:02:54.870
只在博弈树的前三层左右有效

00:02:54.870 --> 00:02:57.469
在这之后 我放弃了 因为对称情况太少了

00:02:57.469 --> 00:03:00.979
而且要检查对称太费力了 不值得

00:03:02.060 --> 00:03:05.270
所以你是说 只靠这些技巧 就足够搜索到

00:03:05.270 --> 00:03:06.630
终局了？

00:03:06.629 --> 00:03:08.189
不尽然

00:03:08.189 --> 00:03:12.159
虽然 alpha-beta 剪枝算法和等效棋局能大幅较少

00:03:12.159 --> 00:03:15.699
棋局的可能情况 但也还是不够

00:03:15.699 --> 00:03:19.810
幸运的是 在寻找优秀的评估函数时 我发现

00:03:19.810 --> 00:03:22.520
自己不需要总是搜索到博弈树的最后

00:03:22.520 --> 00:03:26.710
只要开始有隔墙 我就能知道结果

00:03:26.710 --> 00:03:27.210
为什么呢？

00:03:28.490 --> 00:03:31.629
因为隔墙将两个玩家完全分隔开了

00:03:32.699 --> 00:03:36.289
因此 有更长路径的玩家就能赢

00:03:36.289 --> 00:03:40.879
比如 在这局里 下一步是玩家 O 走

00:03:40.879 --> 00:03:42.949
但结果已经明了了

00:03:42.949 --> 00:03:48.079
因为玩家甲剩下八步可以走 而玩家乙只剩下六步

00:03:48.080 --> 00:03:53.850
好 所以分区、alpha-beta 和对称让你得以搜索到终局

00:03:53.849 --> 00:03:57.269
搜索完所有可能的走法

00:03:57.270 --> 00:04:00.060
有没有谁如果状态一直最佳 就总是能赢呢？

00:04:00.060 --> 00:04:04.009
有的 Thad 玩家乙总是能赢

00:04:04.009 --> 00:04:05.709
我有点意外

00:04:05.710 --> 00:04:10.260
你还说你发现玩家甲有个好起步 对吗？

00:04:10.259 --> 00:04:11.669
对的

00:04:11.669 --> 00:04:15.399
事实上 一开始我以为玩家甲总是能赢

00:04:15.400 --> 00:04:17.259
因为反射效应

00:04:17.259 --> 00:04:19.680
反射效应？ 什么意思？

00:04:19.680 --> 00:04:23.290
反射效应就是将对手走法旋转 180 度

00:04:24.310 --> 00:04:28.530
为了解这个游戏 我发现一个有趣的现象

00:04:28.529 --> 00:04:32.859
如果玩家甲起步在中央 而玩家乙的起步

00:04:32.860 --> 00:04:36.980
是玩家甲可以反射的 那玩家甲就总是能赢

00:04:36.980 --> 00:04:40.110
它只需反射玩家乙走的每一步即可

00:04:41.230 --> 00:04:45.569
好吧 那玩家乙要怎么才能不输呢？

00:04:45.569 --> 00:04:48.290
走到玩家甲不能反射的地方去

00:04:48.290 --> 00:04:52.605
玩家乙总共可以走 24 步 其中能避免反射的有 8 种走法

00:04:52.605 --> 00:04:56.622
我就把这个当练习了 让学员来想想是哪八种

00:04:56.622 --> 00:05:00.287
我们来场比赛吧 让学员试着

00:05:00.286 --> 00:05:02.531
创建最好的孤立玩家

00:05:02.531 --> 00:05:04.219
你要给他们点建议吗？

00:05:04.220 --> 00:05:04.750
肯定的

00:05:05.790 --> 00:05:09.110
如果你是玩家甲 那就走到中央去

00:05:09.110 --> 00:05:12.740
如果可能的话 反射玩家乙的每一步 你就能赢了

00:05:13.860 --> 00:05:16.000
但当玩家乙更好

00:05:17.110 --> 00:05:22.139
你可以建立一个优质开局库 提示

00:05:22.139 --> 00:05:26.479
我们已经探讨了如果玩家甲占据了中心点 要怎么起步最好

00:05:26.480 --> 00:05:30.140
但在大多数情况下 如果玩家甲没有占据中心点

00:05:30.139 --> 00:05:33.079
那玩家乙就应该占据中心点

00:05:34.310 --> 00:05:38.550
不管怎么说 等你创建了一个优质开局库 那就运用你对

00:05:38.550 --> 00:05:43.379
等效走法和散列表的理解 有效加载并搜索你的顺序库

00:05:44.930 --> 00:05:48.699
记住 你能下子的时间有限

00:05:48.699 --> 00:05:53.189
在穷尽开局库后 使用极大极小值算法、

00:05:53.189 --> 00:05:56.346
迭代加深算法以及 alpha-beta 剪枝算法

00:05:57.500 --> 00:06:01.050
最后 集中精力创建评估函数

00:06:01.050 --> 00:06:05.410
一个优质的评估函数需要… 唔 这是你需要思考的事了

00:06:06.480 --> 00:06:07.840
祝你好运

00:06:07.839 --> 00:06:08.449
谢谢你 Malcolm

