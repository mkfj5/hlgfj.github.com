WEBVTT
Kind: captions
Language: zh-CN

00:00:00.770 --> 00:00:04.560
alpha-beta 是个剪枝技巧 能让我们忽略

00:00:04.559 --> 00:00:08.480
博弈树的整个枝节 但仍能得到与极大极小值算法相同的解

00:00:08.480 --> 00:00:11.080
你是说 alpha-beta 不会改变解

00:00:11.080 --> 00:00:12.919
但比极大极小值更高效？

00:00:12.919 --> 00:00:15.830
差不多 一般 alpha-beta 效率高很多

00:00:15.830 --> 00:00:17.910
我们再来看看五步孤立棋

00:00:17.910 --> 00:00:21.339
的三层极大极小树

00:00:21.339 --> 00:00:24.929
假设计算机玩家评估博弈树的方向是

00:00:24.929 --> 00:00:26.050
从左到右

00:00:26.050 --> 00:00:28.850
我们会考虑五棵子树

00:00:28.850 --> 00:00:32.990
看看最左边的这棵 第一个分支只有两个节点

00:00:32.990 --> 00:00:34.920
值分别为 1 和 2

00:00:34.920 --> 00:00:37.490
这是 max 层 所以我们把 2

00:00:37.490 --> 00:00:40.460
向上传递到 min 层

00:00:40.460 --> 00:00:43.820
因为对手 X 会选择能最小化值的分支

00:00:43.820 --> 00:00:46.770
所以我们知道这棵子树的值不会大于 2

00:00:46.770 --> 00:00:50.440
这也就意味着在其它分支上 只要我们看到大于或等于 2 的值

00:00:50.439 --> 00:00:53.839
我们就可以忽略剩下的所有节点了 因为算法永远不会选择它们

00:00:53.840 --> 00:00:54.920
正是

00:00:54.920 --> 00:00:58.329
所以在这三个分支中 最右边的节点分值都是 2

00:00:58.329 --> 00:00:58.869
对的

00:00:58.869 --> 00:01:01.298
也就意味着 11 个节点里 我们可以忽略 6 个

00:01:02.310 --> 00:01:04.709
哇 这可会省下很多时间

00:01:04.709 --> 00:01:06.530
还有更棒的

00:01:06.530 --> 00:01:08.664
我们看看旁边的这棵子树

00:01:08.664 --> 00:01:12.590
一得知左边这个分支值为 2

00:01:12.590 --> 00:01:16.609
我们就知道整棵子树会返回的值肯定是小于或等于 2 的

00:01:16.609 --> 00:01:20.170
但我们已经知道第一棵子树有 2 了

00:01:20.170 --> 00:01:23.540
所以我们知道最高节点的值会大于或等于 2

00:01:24.870 --> 00:01:28.160
也就意味着我们可以忽略

00:01:28.159 --> 00:01:28.679
第二棵子树剩下的所有分支了

00:01:32.099 --> 00:01:36.799
接着看中间的子树 最左边的节点值还是 2

00:01:36.799 --> 00:01:39.719
因为上面的节点还没有任何限制

00:01:39.719 --> 00:01:42.629
所以我们继续探索 又得到一个 2

00:01:42.629 --> 00:01:46.839
没有其它合法走法了 所以这个 max 节点会返回一个 2

00:01:46.840 --> 00:01:53.240
而上面的节点是 min 节点 所以返回的值会小于或等于 2

00:01:53.239 --> 00:01:56.879
而因为我们已经知道最高层有个分支的值

00:01:56.879 --> 00:02:00.826
是 2 了 所以我们可以忽略这棵子树的其它所有节点

00:02:03.099 --> 00:02:04.280
我看出规律了

00:02:04.280 --> 00:02:07.670
第四棵子树我们同样也很快得到了 2

00:02:07.670 --> 00:02:10.430
意味着我们也可以忽略这棵子树的大多数节点

00:02:12.879 --> 00:02:15.108
最后一棵子树也是如此

00:02:18.539 --> 00:02:19.259
等下

00:02:19.259 --> 00:02:20.780
这棵子树实际上走法不好

00:02:20.780 --> 00:02:22.860
它的值实际上是 1

00:02:22.860 --> 00:02:25.140
难道计算机玩家不需要知道这一点吗？

00:02:25.139 --> 00:02:29.589
有什么必要？ 只要我们只想让计算机玩家选择

00:02:29.590 --> 00:02:33.479
和极大极小值算法推荐一样的好棋 那就没必要了

00:02:33.479 --> 00:02:36.209
在这里 计算机选择了最左边的分支

00:02:36.210 --> 00:02:38.640
这和极大极小值算法一样

00:02:38.639 --> 00:02:41.549
可你假设了极大极小值算法是从左到右评估值的

00:02:41.550 --> 00:02:44.050
为了防止僵局 它总会选择最左边的分支

00:02:44.050 --> 00:02:47.469
是的 我们假设目标是玩游戏

00:02:47.469 --> 00:02:50.840
而不是记录某一层所有一样好的走法

00:02:50.840 --> 00:02:51.870
太好了

00:02:51.870 --> 00:02:55.439
看看这整棵树 看起来我们并不用观察大部分节点

00:02:55.439 --> 00:02:58.740
整棵树有 78 个节点 我们只需看 29 个就行了

00:02:58.740 --> 00:03:01.439
这能省好多时间

00:03:01.439 --> 00:03:04.625
事实上 极大极小值算法耗时 b^d

00:03:04.625 --> 00:03:08.689
配合 alpha-beta 剪枝的极大极小值算法耗时只有 b^d/2

00:03:08.689 --> 00:03:12.680
如果节点以最佳方式排序 最好的走法就在左边的话

00:03:12.680 --> 00:03:14.260
就算是随机排序

00:03:14.259 --> 00:03:18.759
alpha-beta 剪枝也能将预计耗时减少到 b^3d/4

