WEBVTT
Kind: captions
Language: zh-CN

00:00:00.360 --> 00:00:03.299
我们来谈谈别的评估函数

00:00:03.299 --> 00:00:07.569
使用 #my_moves- #opponents_moves

00:00:08.589 --> 00:00:12.279
对于简单的孤立棋 我真的很喜欢用这个函数变体

00:00:12.279 --> 00:00:15.554
孤立棋的精髓就在于减少对手步数

00:00:15.554 --> 00:00:19.615
#my_moves- #opponents_moves 能够让计算机玩家寻找

00:00:19.615 --> 00:00:24.414
能有最多步数的走法 同时想方设法影响对手步数

00:00:24.414 --> 00:00:28.161
我们甚至还可以给公式的成分添加权重

00:00:28.161 --> 00:00:30.417
增大游戏攻击性或降低游戏攻击性

00:00:30.417 --> 00:00:35.121
比如 #my_ moves- 2 *
#opponent_moves 会使得

00:00:35.121 --> 00:00:38.292
计算机玩家追逐对手

00:00:38.292 --> 00:00:39.823
这让你说的那个例子

00:00:39.823 --> 00:00:42.269
关于水平效应的那个 更好玩了

00:00:42.270 --> 00:00:43.540
怎么说？

00:00:43.539 --> 00:00:47.289
因为现在能赢的走法评估分值最高

00:00:47.289 --> 00:00:51.259
这是能赢的走法 现在评估函数返回结果为 1

00:00:51.259 --> 00:00:54.429
而右走一格的结果是 -2

00:00:54.429 --> 00:00:58.369
走到最右边的结果是 -1

00:00:58.369 --> 00:01:01.439
走到最左下的结果是 0

00:01:01.439 --> 00:01:03.059
或许这就是我们要的函数

00:01:03.060 --> 00:01:04.939
或许保持两者有差不多的选择

00:01:04.939 --> 00:01:07.989
但离对手更近些 是孤立棋的好策略

00:01:07.989 --> 00:01:09.159
我不知道

00:01:09.159 --> 00:01:12.109
我觉得要确定评估函数 唯一的办法是尝试多种

00:01:12.109 --> 00:01:14.939
评估函数 看看哪个是最好的

00:01:14.939 --> 00:01:15.659
说得对

00:01:15.659 --> 00:01:18.060
但是除了极大极小值算法和迭代加深

00:01:18.060 --> 00:01:21.998
我们还要讲一个技巧 这个技巧对提高

00:01:21.998 --> 00:01:25.410
博弈树搜索效率极有帮助 所以在我们调整评估函数之前 先来讲讲这个吧

