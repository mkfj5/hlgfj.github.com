WEBVTT
Kind: captions
Language: zh-CN

00:00:00.260 --> 00:00:02.910
我们来看一个迭代加深的简单案例

00:00:02.910 --> 00:00:05.110
这次要应用的对象是分枝因子为 2 的博弈树

00:00:05.110 --> 00:00:08.108
在第零层 只有 1 个节点需要搜索

00:00:08.108 --> 00:00:10.720
在第一层 我们再次搜索第一个节点

00:00:10.720 --> 00:00:13.190
然后搜索两个子节点

00:00:13.189 --> 00:00:17.609
也就是搜索第一层时 我们需要搜索 3 个节点 还要加上

00:00:17.609 --> 00:00:22.518
第零层的 1 个节点 所以迭代加深节点总数是 4 个

00:00:22.518 --> 00:00:26.760
到了第二层 我们加上了博弈树底层的 4 个节点

00:00:26.760 --> 00:00:30.260
为了加上这些节点 我们还得看上面的 3 个节点

00:00:30.260 --> 00:00:32.130
所以这一层总共要搜索 7 个节点

00:00:32.130 --> 00:00:37.005
所以加上第二层 迭代加深要搜索的节点总数为 11 个

00:00:37.005 --> 00:00:39.625
到了第三层 我们要多加 8 个节点

00:00:39.625 --> 00:00:43.284
所以为了搜索这一层 总共要搜索 15 个节点

00:00:43.284 --> 00:00:45.214
迭代加深总数为 26

00:00:45.215 --> 00:00:49.980
注意 每层要访问的节点总数

00:00:49.979 --> 00:00:52.129
和迭代加深需要重访的节点总数

00:00:52.130 --> 00:00:56.370
实际上会小于因该层而增加的节点数的两倍

00:00:56.369 --> 00:01:00.589
第四层的深度有限搜索需要检查 31 个节点

00:01:00.590 --> 00:01:02.240
但迭代加深总数为 57 个

00:01:02.240 --> 00:01:05.750
第五层的深度有限搜索需要检查 63 个

00:01:05.750 --> 00:01:07.560
迭代加深是 120 个

00:01:07.560 --> 00:01:11.329
虽然重复搜索博弈树似乎有点无谓

00:01:11.329 --> 00:01:15.289
但比起一层一层往下搜索的指数增长

00:01:15.290 --> 00:01:16.730
这个倍数增长就很小了

00:01:16.730 --> 00:01:18.770
在分枝因子为 2 的情况下

00:01:18.769 --> 00:01:22.569
在同一层里 迭代加深膨胀的幅度要小于

00:01:22.569 --> 00:01:25.359
深度迭代要搜索的节点数的两倍

00:01:25.359 --> 00:01:28.879
如果分枝因子大于 2 这也是大多数游戏情况

00:01:28.879 --> 00:01:32.079
那么迭代加深造成的浪费相比起来就更小了

00:01:32.079 --> 00:01:33.329
我们来快速做一个练习吧 或许能帮助你理解

