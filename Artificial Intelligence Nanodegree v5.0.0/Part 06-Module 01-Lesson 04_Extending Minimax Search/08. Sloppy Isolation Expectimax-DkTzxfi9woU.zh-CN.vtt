WEBVTT
Kind: captions
Language: zh-CN

00:00:00.290 --> 00:00:04.759
为了阐述这个思路 我们来看一个简单的六步孤立棋局

00:00:04.759 --> 00:00:08.050
这里加了绿圆圈 表示概率节点

00:00:08.050 --> 00:00:11.750
现在轮到了 O O 有四种走法

00:00:11.750 --> 00:00:16.259
我们要探索的第一个节点

00:00:16.260 --> 00:00:17.580
是 O 要走到左上角去

00:00:17.579 --> 00:00:21.280
但 O 只有 90% 成功的几率

00:00:21.280 --> 00:00:25.349
还有 10% 的几率 O 会落到左边相邻的空格里

00:00:25.350 --> 00:00:29.609
对的 还有一种走法 O 想往走走一步

00:00:29.609 --> 00:00:34.719
也是 90% 成功的几率 但也有 10% 的几率会走过头

00:00:34.719 --> 00:00:36.969
但是 如果 O 想走到其它两个位置

00:00:36.969 --> 00:00:40.289
那就不会走过头 也不会走不到 要到其它位置很容易

00:00:40.289 --> 00:00:43.750
对的 但是我们先来重点看看最左边的分支

00:00:43.750 --> 00:00:47.250
轮到 X 后 X 有三种走法

00:00:47.250 --> 00:00:50.898
X 可以向左走一格 有 90% 成功的几率

00:00:50.898 --> 00:00:52.970
10% 走过头

00:00:52.969 --> 00:00:56.570
同理 如果 X 想走到最右边

00:00:56.570 --> 00:01:00.948
那有 90% 成功的几率和 10% 走不到的几率

00:01:00.948 --> 00:01:04.989
如果 X 想朝右上走 那 100% 会成功

00:01:04.989 --> 00:01:07.520
现在我们可以开始计算了

00:01:07.519 --> 00:01:12.109
使用我们的标准评估函数 #my_moves

00:01:12.109 --> 00:01:16.900
O 在这个棋盘里有一种走法 这个则有两个子节点

00:01:16.900 --> 00:01:24.936
也就是说 这个分支的预测值是 0.9 x 1 + 0.1 x 2 也就是 1.1

00:01:24.936 --> 00:01:29.480
至于旁边的这个节点 就是节点值 2 乘以 0.9

00:01:29.480 --> 00:01:32.920
再加右边的节点值 1 乘以 0.1 的乘积

00:01:32.920 --> 00:01:36.239
但是要注意 我们不必评估右边的节点

00:01:36.239 --> 00:01:41.518
因为这一层是 min 层 所以一看到 0.9 乘以 2

00:01:41.518 --> 00:01:47.590
得到 1.8 这就已经比左边的 1.1 大了

00:01:47.590 --> 00:01:49.920
所以我们知道 我们永远不会用这个节点

00:01:49.920 --> 00:01:52.260
所以我们根本不必评估这个节点

00:01:52.260 --> 00:01:55.175
在这里是可以的 因为我们知道这个评估函数不会

00:01:55.174 --> 00:01:56.094
小于 0

00:01:56.094 --> 00:01:58.834
但如果评估函数可以得到负值呢？

00:01:58.834 --> 00:02:00.414
那我们就不能剪枝了

00:02:00.415 --> 00:02:04.375
总地来说 用期望最大化算法 剪枝是需要前提的 那就是得知道

00:02:04.375 --> 00:02:08.064
期望最大化函数返回值的范围

00:02:08.064 --> 00:02:11.264
好的 所以在这里 实际上我们要选下一个分支 因为它的值是 1

00:02:11.264 --> 00:02:13.404
概率也是 1

00:02:13.405 --> 00:02:16.305
所以这个节点的期望值是 1

00:02:16.305 --> 00:02:17.935
我们来试试旁边这棵子树

00:02:19.069 --> 00:02:20.180
这个很简单

00:02:20.180 --> 00:02:23.590
看看底层节点 所有节点评估值都为 2

00:02:23.590 --> 00:02:27.240
因此所有分支评估结果都会是 2 这个节点的值也会是 2

00:02:27.240 --> 00:02:30.030
好极了 来看下一棵子树

00:02:30.030 --> 00:02:34.783
还是一样 所有下层节点都是 2 所以这个节点的值也是 2

00:02:34.782 --> 00:02:36.757
下一棵子树则有趣多了

00:02:36.758 --> 00:02:41.469
在底层最左边的节点上 O 只剩一种走法

00:02:41.469 --> 00:02:43.729
1 要乘以 0.9

00:02:43.729 --> 00:02:47.489
再加上 2 乘以 0.1 的乘积

00:02:47.490 --> 00:02:53.400
因为旁边这个节点 X 走过头的概率是 0.1 所以总和是 1.1

00:02:53.400 --> 00:02:54.480
再看下一个分支

00:02:54.479 --> 00:02:59.795
如果 X 想走到右尽头 那我们就有 2 乘以 0.9 也就是 1.8

00:02:59.795 --> 00:03:01.929
现在我们可以把另一个分支剪掉了

00:03:01.930 --> 00:03:04.730
为讲课方便 我们还是把计算过程讲一讲吧

00:03:04.729 --> 00:03:09.968
好的 评估函数 #my_moves 在这里的结果是 1

00:03:09.968 --> 00:03:14.019
所以 2 乘以 0.9 加 1 乘以 0.1 就等于 1.9

00:03:14.019 --> 00:03:16.260
但最后一个选择是最优的

00:03:16.259 --> 00:03:19.631
它会返回一个 1 概率为 100%

00:03:19.631 --> 00:03:22.009
所以这个节点的值是 1

00:03:22.009 --> 00:03:26.731
下一个选择则很容易计算 所有值都是 2

00:03:26.731 --> 00:03:30.689
在这之后的也很容易 所有走法的准确性都是 100%

00:03:30.689 --> 00:03:33.409
由于这是 min 节点 所以我们选择 1

00:03:33.409 --> 00:03:36.778
太好了 现在我们已经计算好所有的值

00:03:36.778 --> 00:03:39.849
可以为顶部的 max 节点选出分值最大的分支了

00:03:39.849 --> 00:03:41.599
看起来这个分支赢了

00:03:41.599 --> 00:03:44.489
对的 不过在这个示例游戏里 这帮不了 O 什么

00:03:44.490 --> 00:03:48.200
O 会输的 除非 X 走得不好或者运气差

00:03:48.199 --> 00:03:50.599
但如果我们知道玩家 O 要输

00:03:50.599 --> 00:03:53.530
我们何不试着选一个

00:03:53.530 --> 00:03:55.550
X 有可能不走运或走得不好的分支呢？

00:03:55.550 --> 00:03:56.890
有道理

00:03:56.889 --> 00:03:59.939
事实上 如果我们用这个算法一直搜索到终局

00:03:59.939 --> 00:04:03.699
算法可能会选一个 X 可能不走运并输了的分支

00:04:03.699 --> 00:04:06.239
遗憾的是 我们这个简单的 #my_moves 评估函数

00:04:06.240 --> 00:04:10.150
并不能真的捕捉到这一概率

00:04:10.150 --> 00:04:13.094
更深入地搜索 直到终局 倒是能解决问题

00:04:13.094 --> 00:04:14.518
而且也是个很好的练习

00:04:14.518 --> 00:04:18.129
但现在我们已经讲完了所有知识点 我都等不及要回过头来谈谈

00:04:18.129 --> 00:04:20.420
本节初提到的那个很有挑战性的问题了

