WEBVTT
Kind: captions
Language: zh-CN

00:00:00.320 --> 00:00:02.496
假设我们有两个不太相似的信号

00:00:02.496 --> 00:00:07.269
动态时间规整可以让他们更好地匹配

00:00:07.269 --> 00:00:09.990
观察这个例子 我们使用了不同的短信号

00:00:09.990 --> 00:00:12.830
和前一个例子中相同长度的信号

00:00:12.830 --> 00:00:13.800
— 好

00:00:13.800 --> 00:00:16.429
— 我们首先匹配 0 和 3

00:00:16.429 --> 00:00:19.620
我把 x 轴序列的前半部分与 3 匹配

00:00:19.620 --> 00:00:23.140
然后对序列的负数部分 得到更好的匹配

00:00:23.140 --> 00:00:25.850
然后我再次回到两个序列的正数部分

00:00:25.850 --> 00:00:27.429
— 没错 这里存在一个问题

00:00:27.429 --> 00:00:30.500
在这个例子中 因为这些数字出现在序列的第一部分

00:00:30.500 --> 00:00:33.189
与 3 匹配 距离很差

00:00:33.189 --> 00:00:35.799
但是经过允许范围内的几次调整

00:00:35.799 --> 00:00:38.959
表明距离远远小于我们的期望

00:00:38.960 --> 00:00:41.859
— 我们要进行更加合理的匹配

00:00:41.859 --> 00:00:44.030
其中一种方式是约束我们偏离直线的距离

00:00:44.030 --> 00:00:48.090
— 对 我们可以使用 Sakoe Chiba 约束 进行更加合理的匹配

00:00:48.090 --> 00:00:49.903
— Sakoe Chiba 现在你只整理一下

00:00:49.902 --> 00:00:52.009
— 不是这样

00:00:52.009 --> 00:00:54.570
这表明我们不允许在这些直线

00:00:54.570 --> 00:00:56.920
范围以外的匹配

00:00:56.920 --> 00:00:59.969
— 这会导致匹配更差 引起更大的距离

00:00:59.969 --> 00:01:01.439
— 这是我们不想要的结果

00:01:01.439 --> 00:01:03.176
— 我们如何计算这些约束？

00:01:03.176 --> 00:01:06.349
— 经常从经验来说 我们设置不同的约束

00:01:06.349 --> 00:01:09.030
使用交叉验证确保它们是合理的

00:01:09.030 --> 00:01:11.920
— 如果一部分信号与其他部分

00:01:11.920 --> 00:01:12.820
不同怎么办？

00:01:12.819 --> 00:01:17.729
— 例如在我们例子中 这里的部分可能有许多更短的方差

00:01:17.730 --> 00:01:22.790
但是隆起部分具有更小的差异性和形状

00:01:22.790 --> 00:01:26.410
— 而且最后一部分再次出现更大的差异性

00:01:26.409 --> 00:01:28.289
一般来说 这里有三部分的信号

00:01:28.290 --> 00:01:30.859
每部分都允许有不同数量的规整

00:01:30.859 --> 00:01:33.760
— 我们尽量在信号的每部分

00:01:33.760 --> 00:01:35.290
使用不同的 Sakoe Chiba 约束

00:01:35.290 --> 00:01:37.530
— 的确如此 不过训练时看起来非常复杂

00:01:37.530 --> 00:01:40.530
我知道对于这些问题你更喜欢用隐马尔可夫模型

00:01:40.530 --> 00:01:41.840
为什么不试试呢？

00:01:41.840 --> 00:01:43.859
— 好的 你知道这也是我最喜欢的技巧.
最新课程跟课件还有一对一辅导请加wx：udacity6

