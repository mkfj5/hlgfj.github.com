WEBVTT
Kind: captions
Language: zh-CN

00:00:00.300 --> 00:00:04.129
那么动态时间规整是为了调整

00:00:04.129 --> 00:00:06.767
我们对比两次哨音之间的样本 这样它们可以最好地匹配起来

00:00:06.767 --> 00:00:07.173
— 没错

00:00:07.174 --> 00:00:12.170
我们在 x 轴和 y 轴上调整想要对比的两个信号

00:00:12.169 --> 00:00:15.660
这可以让我们更容易地看到我们如何匹配样本

00:00:15.660 --> 00:00:19.219
— 为了方便 我们把较短的放在 y 轴上

00:00:19.219 --> 00:00:22.429
— 没有进行时间规整的匹配会是一条

00:00:22.429 --> 00:00:25.699
从左下方到右上方的斜向直线

00:00:25.699 --> 00:00:28.780
但是对于我们对比的信号类型 这是非常罕见的

00:00:28.780 --> 00:00:31.720
— 我们知道从每个信号的第一个样本开始

00:00:31.719 --> 00:00:34.109
在这个例子中 两者都是 0

00:00:34.109 --> 00:00:37.460
— x 轴上的下一个样本 还是 0

00:00:37.460 --> 00:00:40.609
在更短序列中维持 0 更好呢？

00:00:40.609 --> 00:00:43.240
还是在接下来的样本中转变为 5 更好呢？

00:00:43.240 --> 00:00:46.539
— 其实如果维持 0 会很少存在差异

00:00:46.539 --> 00:00:50.609
— 那么我们在这里绘制一条横线 表明我们首先匹配 x 轴上前两个 0

00:00:50.609 --> 00:00:54.890
和 y 轴上的第一个 0

00:00:54.890 --> 00:00:56.969
— 接下来的样本中我们得到 2

00:00:56.969 --> 00:00:59.679
这仍然比 5 更好地匹配 0

00:00:59.679 --> 00:01:01.640
— 那我们继续画横线

00:01:01.640 --> 00:01:05.090
— 然后我们到达 x 轴上的 3 可以与 5 更好地匹配

00:01:05.090 --> 00:01:08.579
— 所以我们转向 y 轴的 1 表示这个

00:01:08.579 --> 00:01:12.064
— 接下来 x 轴还有几个连续的 3

00:01:12.064 --> 00:01:14.875
我们怎么把它们与 y 轴上的 5 匹配呢？

00:01:14.875 --> 00:01:17.647
— 我们需要转化为 y 轴上的

00:01:17.647 --> 00:01:19.474
2 和 0

00:01:19.474 --> 00:01:20.974
那么我们进行转换

00:01:20.974 --> 00:01:24.034
使我们尽可能靠近直线

00:01:24.034 --> 00:01:24.814
— 我明白了

00:01:24.814 --> 00:01:27.304
我们试图尽可能接近匹配值

00:01:27.305 --> 00:01:28.365
最小化误差

00:01:28.364 --> 00:01:31.644
如果数据是连续的 我们要尽量靠近直线

00:01:31.644 --> 00:01:35.349
— 对的 3 和 5 可以更好地匹配

00:01:35.349 --> 00:01:39.259
我们得到 2 时 3 和 2 可以更好地匹配

00:01:39.260 --> 00:01:40.050
我们在 x 轴上得到 2 和 1 时

00:01:40.049 --> 00:01:44.840
可以很好地匹配上面的 2 和 0

00:01:44.840 --> 00:01:47.579
0 和 -1 可以更好地匹配 0

00:01:47.579 --> 00:01:50.783
— 然后我们可以匹配 x 轴上的 -2 -3 -3 和 -1

00:01:50.784 --> 00:01:56.540
和 y 轴上的 3 和 -3

00:01:56.540 --> 00:02:00.042
— 长序列的剩余部分 0 1 1 1 1

00:02:00.042 --> 00:02:04.000
与 y 轴的 1 1 和 2 匹配

00:02:04.000 --> 00:02:09.449
最后的 1 和最后的 2 匹配 结束这个过程

00:02:09.449 --> 00:02:12.180
— 我们之前可以计算欧几里得距离

00:02:12.180 --> 00:02:14.230
但是这次我们得到更好匹配

00:02:14.229 --> 00:02:15.781
— 没错 写下来

00:02:15.782 --> 00:02:21.510
我们得到的距离如下 0 减去 0 的平方等于 0

00:02:21.509 --> 00:02:24.169
再次是 0 减去 0 的平方还是 0

00:02:25.289 --> 00:02:28.199
2 减去 0 的平方是 4

00:02:28.199 --> 00:02:31.119
3 减去 5 的平方是 4

00:02:31.120 --> 00:02:32.599
— 我认为我们理解了这个理论

00:02:32.599 --> 00:02:33.060
— 抱歉

00:02:33.060 --> 00:02:36.754
我还是认为这些内容写出来更容易理解

00:02:36.754 --> 00:02:40.495
通过这些潦草的涂画 我们得到距离是 34 的平方根

00:02:40.495 --> 00:02:42.844
约等于 6

00:02:42.844 --> 00:02:45.645
— 与之前我们用 0 填补较短序列相比

00:02:45.645 --> 00:02:47.930
这次是之前计算距离的不足一半

00:02:47.930 --> 00:02:50.379
— 这表现了动态时间规整的神奇之处

00:02:50.379 --> 00:02:53.252
在我们了解所对比的信号情景中

00:02:53.252 --> 00:02:55.436
与各部分相比 我们有更快的部分

00:02:55.436 --> 00:02:58.087
也有更慢的部分

00:02:58.086 --> 00:02:59.879
动态时间规整是非常有效的工具

00:02:59.879 --> 00:03:01.409
— 不过我发现一个问题

00:03:01.409 --> 00:03:01.969
— 什么问题？

