WEBVTT
Kind: captions
Language: zh-CN

00:00:00.220 --> 00:00:04.339
导航作为一个很棘手的计算难题

00:00:04.339 --> 00:00:06.929
很好地体现了人工智能的作用 有了人工智能 问题就能更高效地得到解决

00:00:06.929 --> 00:00:09.059
你说很棘手的计算难题是什么意思？

00:00:09.060 --> 00:00:12.580
是指那些具有高时间或空间复杂度的问题吗？

00:00:12.580 --> 00:00:13.740
对的 就是这些

00:00:13.740 --> 00:00:15.320
我来具体说明一下吧

00:00:15.320 --> 00:00:19.719
我打算制定一条公路旅行路线 从英国曼彻斯特到谢菲尔德市

00:00:19.719 --> 00:00:23.029
而且我想找出最短路线

00:00:23.030 --> 00:00:25.390
知道了不同城市和市镇

00:00:25.390 --> 00:00:27.080
的位置

00:00:27.079 --> 00:00:31.589
以及连接这些城镇的道路 我能不能让计算机帮我解决这个难题呢？

00:00:31.589 --> 00:00:35.271
— 当然可以 这听起来就像个简单的搜索问题 我们只需绘制城市节点

00:00:35.271 --> 00:00:36.676
以及连接节点的公路边缘

00:00:36.676 --> 00:00:39.090
用宽度优先搜索就能解决 对吧？

00:00:39.090 --> 00:00:42.830
是的 但看看我用宽度优先搜索之后的结果

00:00:42.829 --> 00:00:46.689
搜索会考虑从起始城市出发的所有可能路线

00:00:46.689 --> 00:00:49.280
直到在这些路线中找出能抵达目的城市的那条

00:00:50.710 --> 00:00:54.060
那可不怎么高效啊 而且你这显示的只有主要道路

00:00:54.060 --> 00:00:56.320
可如果把小街道、小巷也考虑进去

00:00:56.320 --> 00:01:00.159
我想搜索可能路线所需的空间很快就要大得失控了

00:01:00.159 --> 00:01:03.089
对的 所以这个时候就要用到人工智能了

00:01:03.090 --> 00:01:05.767
告诉我 如果手动规划这次旅行

00:01:05.766 --> 00:01:07.713
你会怎么解决这个问题？

00:01:07.713 --> 00:01:09.932
恩 我看到谢菲尔德是在曼彻斯特的东边 偏南方

00:01:09.932 --> 00:01:13.481
所以我可能会只考虑几条主要车道

00:01:13.481 --> 00:01:16.500
就通向那个方向的那些

00:01:16.500 --> 00:01:19.010
至于看起来就离目的地太远的道路

00:01:19.010 --> 00:01:22.719
我可能就直接忽略了 或者先放到一边 晚点再考虑

00:01:22.719 --> 00:01:25.579
我肯定是先考虑那些看起来

00:01:25.579 --> 00:01:26.989
能带我接近目的地的路线

00:01:26.989 --> 00:01:30.015
就是这样 这是个极好的启发法

00:01:30.015 --> 00:01:32.084
说实话 我不知道齐发法是什么

00:01:32.084 --> 00:01:32.876
是启发法

00:01:34.159 --> 00:01:35.579
那是人工智能的智慧所在

00:01:36.609 --> 00:01:40.859
基本上 启发法指的是一些额外的信息 比如一条规则、

00:01:40.859 --> 00:01:44.909
一个函数或一个限制 告知暴力算法

00:01:44.909 --> 00:01:46.439
以更优化的方式来计算

00:01:47.480 --> 00:01:50.549
我知道了 但我刚才说的好像不够准确

00:01:50.549 --> 00:01:52.649
不能作为真正的算法使用啊

00:01:52.650 --> 00:01:54.170
你会大开眼界的

00:01:54.170 --> 00:01:57.180
我们先在起始地和目的地之间画一条直线

00:01:57.180 --> 00:02:00.050
这就是我们能找到的最短可能路线了

00:02:00.049 --> 00:02:02.159
如果两座城市是直接相通的话

00:02:02.159 --> 00:02:03.549
对的 乌鸦就会这么飞过去

00:02:03.549 --> 00:02:08.500
是的 现在我们来想想 随机向任意方向走一步

00:02:08.500 --> 00:02:11.520
那么前往目的地的直接距离就有了变化

00:02:11.520 --> 00:02:13.080
事实上 变得更大了

00:02:13.080 --> 00:02:16.210
也就意味着 我们有效地偏离了目的地

00:02:17.240 --> 00:02:18.460
我们走另一步看看

00:02:19.840 --> 00:02:21.800
看起来这次距离缩小了

00:02:21.800 --> 00:02:23.350
我们离目标更近了

00:02:23.349 --> 00:02:24.276
对的

00:02:24.276 --> 00:02:28.116
从现有位置出发 我们不断测试所有可能的下一步

00:02:28.116 --> 00:02:31.640
然后选一步离下一步的直线距离最小的

00:02:31.640 --> 00:02:34.954
唔 可你没有考虑到一点 虽然现在的下一步

00:02:34.955 --> 00:02:37.560
看起来像是最佳选择

00:02:37.560 --> 00:02:40.340
但最后可能不在最佳路线上

00:02:40.340 --> 00:02:41.680
说得好

00:02:41.680 --> 00:02:45.849
注意 我们只用直接距离启发法来决定

00:02:45.849 --> 00:02:47.560
下一步要探索哪里

00:02:47.560 --> 00:02:51.711
我们并不是真的把其它可能性都抛开了 只是把它们储存起来

00:02:51.711 --> 00:02:55.457
以备考虑 免得那些看起来更好的路线都没有用

00:02:55.456 --> 00:02:58.993
好 所以这是在帮我们指引算法去优先考虑

00:02:58.993 --> 00:03:01.680
和评估某些可能性

00:03:01.680 --> 00:03:04.914
这倒或许能避免一些不必要的搜索

00:03:04.913 --> 00:03:06.701
但能多有效呢？

00:03:06.701 --> 00:03:10.050
我们来运行看看

00:03:10.050 --> 00:03:11.320
好

00:03:11.319 --> 00:03:13.919
看着的确探索了些额外的路线

00:03:13.919 --> 00:03:16.709
但很快就汇聚到最优方向上了

00:03:16.710 --> 00:03:20.379
是的 这个算法叫 A* 搜索

00:03:20.379 --> 00:03:24.650
是目前最流行 也是最有效的人工智能算法之一

00:03:24.650 --> 00:03:27.010
在搜索课程中 我们会更深入地学习该算法

