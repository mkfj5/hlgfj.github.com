WEBVTT
Kind: captions
Language: en

00:00:00.220 --> 00:00:04.339
Navigation is an excellent example
of a computationally hard problem

00:00:04.339 --> 00:00:06.929
that AI can help solve more efficiently.

00:00:06.929 --> 00:00:09.059
&gt;&gt; What do you mean by
computationally hard,

00:00:09.060 --> 00:00:12.580
problems that have a high time or
space complexity?

00:00:12.580 --> 00:00:13.740
&gt;&gt; Yeah, precisely.

00:00:13.740 --> 00:00:15.320
Let me illustrate.

00:00:15.320 --> 00:00:19.719
I'm trying to plan a road trip from
Manchester to Sheffield in the UK and

00:00:19.719 --> 00:00:23.029
for that, I wish to find
the shortest path between them.

00:00:23.030 --> 00:00:25.390
Given the information about
where different cities and

00:00:25.390 --> 00:00:27.080
towns are located and

00:00:27.079 --> 00:00:31.589
what roadways connect them, can I use
a computer to do the hard work for me?

00:00:31.589 --> 00:00:35.271
&gt;&gt; Sure, this seem like a simple search
problem to do graph of city nodes

00:00:35.271 --> 00:00:36.676
connected by road edges.

00:00:36.676 --> 00:00:39.090
Breadth-first search can handle that,
right?

00:00:39.090 --> 00:00:42.830
&gt;&gt; Yeah, but look what happens
when I apply breadth-first search.

00:00:42.829 --> 00:00:46.689
It starts considering all the possible
paths out of the source city til

00:00:46.689 --> 00:00:49.280
it reaches the desired destination
on one of those paths.

00:00:50.710 --> 00:00:54.060
&gt;&gt; That's not very efficient and
you're only showing major roadways.

00:00:54.060 --> 00:00:56.320
If you consider smaller streets and
alleys,

00:00:56.320 --> 00:01:00.159
I'm guessing the space of possible paths
to search can easily become intractable.

00:01:00.159 --> 00:01:03.089
&gt;&gt; Right, and that's where AI comes in.

00:01:03.090 --> 00:01:05.767
Tell me,
if you were manually planning this trip,

00:01:05.766 --> 00:01:07.713
how would you approach the problem?

00:01:07.713 --> 00:01:09.932
&gt;&gt; Well, I can see that
Sheffield is in the east and

00:01:09.932 --> 00:01:13.481
slightly south of Manchester, so
I'd probably only consider the few major

00:01:13.481 --> 00:01:16.500
roadways that are coming
out in that direction.

00:01:16.500 --> 00:01:19.010
Paths that I see going too
far away from my destination,

00:01:19.010 --> 00:01:22.719
I might just ignore them or
keep them aside to be considered later.

00:01:22.719 --> 00:01:25.579
I would definitely give priority to
paths that I can see are getting me

00:01:25.579 --> 00:01:26.989
closer to my destination.

00:01:26.989 --> 00:01:30.015
&gt;&gt; There you go, that's
a perfectly fine heuristic to use.

00:01:30.015 --> 00:01:32.084
&gt;&gt; I don't know how to
drive stick actually.

00:01:32.084 --> 00:01:32.876
&gt;&gt; Heuristic.

00:01:34.159 --> 00:01:35.579
&gt;&gt; That's AI for smarts.

00:01:36.609 --> 00:01:40.859
Basically, a heuristic is some
additional piece of information, a rule,

00:01:40.859 --> 00:01:44.909
function or constraint, that informs
an otherwise brute-force algorithm

00:01:44.909 --> 00:01:46.439
to act in a more optimal manner.

00:01:47.480 --> 00:01:50.549
&gt;&gt; I see, but what I just described
seems too imprecise to be

00:01:50.549 --> 00:01:52.649
factored into a real algorithm.

00:01:52.650 --> 00:01:54.170
&gt;&gt; You will be surprised.

00:01:54.170 --> 00:01:57.180
Let's draw a straight line between
the source and destination.

00:01:57.180 --> 00:02:00.050
This is the shortest possible
path we could ever take

00:02:00.049 --> 00:02:02.159
if the two cities were
directly connected.

00:02:02.159 --> 00:02:03.549
&gt;&gt; Right, as the crow flies.

00:02:03.549 --> 00:02:08.500
&gt;&gt; Yeah, now let's consider taking
a random step in any direction.

00:02:08.500 --> 00:02:11.520
The new direct distance to
the destination has changed.

00:02:11.520 --> 00:02:13.080
In fact, it has become greater,

00:02:13.080 --> 00:02:16.210
which means we have effectively
gone away from the destination.

00:02:17.240 --> 00:02:18.460
Let's consider a different step.

00:02:19.840 --> 00:02:21.800
&gt;&gt; This time it looks like
our distance has shrunk so

00:02:21.800 --> 00:02:23.350
we have moved closer to our goal.

00:02:23.349 --> 00:02:24.276
&gt;&gt; That's right,

00:02:24.276 --> 00:02:28.116
we keep testing all possible next
steps from the current position and

00:02:28.116 --> 00:02:31.640
pick the one with the smallest
direct distance to move to next.

00:02:31.640 --> 00:02:34.954
&gt;&gt; Hm, one thing you haven't
considered though is that it seems like

00:02:34.955 --> 00:02:37.560
the current next step that
seems like the best choice

00:02:37.560 --> 00:02:40.340
may not turn out to be
on the optimal path.

00:02:40.340 --> 00:02:41.680
&gt;&gt; Good catch.

00:02:41.680 --> 00:02:45.849
Note that we are only using our direct
distance heuristic to decide which step

00:02:45.849 --> 00:02:47.560
to explore next.

00:02:47.560 --> 00:02:51.711
We're not really throwing away the other
possibilities, merely storing them for

00:02:51.711 --> 00:02:55.457
later consideration, in case none of
the more promising paths works out.

00:02:55.456 --> 00:02:58.993
&gt;&gt; Okay, so this helps us prioritize
how our algorithm considers and

00:02:58.993 --> 00:03:01.680
evaluates different possibilities.

00:03:01.680 --> 00:03:04.914
I can see that it may prevent
some unnecessary searching,

00:03:04.913 --> 00:03:06.701
but how effective is it really?

00:03:06.701 --> 00:03:10.050
&gt;&gt; Well, let's run it and figure out.

00:03:10.050 --> 00:03:11.320
&gt;&gt; Neat.

00:03:11.319 --> 00:03:13.919
It does seem to explore
some additional paths, but

00:03:13.919 --> 00:03:16.709
it converges on the optimal
direction pretty quickly.

00:03:16.710 --> 00:03:20.379
&gt;&gt; Yeah, the exact method
here is called A* Search and

00:03:20.379 --> 00:03:24.650
is one of the most popular, yet
effective, AI algorithms out there.

00:03:24.650 --> 00:03:27.010
We'll learn more about
it in the search lesson.

