WEBVTT
Kind: captions
Language: zh-CN

00:00:00.250 --> 00:00:02.839
说到节省深度搜索的时间

00:00:02.839 --> 00:00:06.070
还有一个强大的技巧 即观察问题结构

00:00:06.070 --> 00:00:09.710
看看能否将问题分解成多个独立的问题

00:00:09.710 --> 00:00:13.620
比如 塔斯马尼亚与澳大利亚问题的其它部分不相关

00:00:13.619 --> 00:00:15.359
可以单独解决

00:00:15.359 --> 00:00:17.619
这就为搜索树减少了一层

00:00:17.620 --> 00:00:21.109
总地来说 假设我们的问题有 80 个二元变量

00:00:21.109 --> 00:00:24.390
我们可以将其分成四个具备 20 个变量的问题

00:00:24.390 --> 00:00:30.740
这样搜索空间就从 2^80 变成 4 * 2^20 了

00:00:30.739 --> 00:00:32.969
更妙的是 如果约束传播问题没有循环

00:00:32.969 --> 00:00:38.310
那我们就可以在 O(nd^2) 时间内解决问题 而不需耗费 O(d^n)

00:00:38.310 --> 00:00:39.469
怎么说？

00:00:39.469 --> 00:00:41.629
我们任选一个变量作为树根

00:00:41.630 --> 00:00:43.010
然后选出一个变量序列

00:00:43.009 --> 00:00:46.509
使树中每个变量都在其父代之后出现

00:00:46.509 --> 00:00:49.229
然后我们从末端开始 令每个父变量弧相容

00:00:49.229 --> 00:00:51.669
沿着树不断向上 直到抵达树顶

00:00:51.670 --> 00:00:53.520
如果做不到呢？

00:00:53.520 --> 00:00:55.640
那就报告问题求解失败

00:00:55.640 --> 00:00:57.549
好 那接着呢？

00:00:57.549 --> 00:00:59.579
很简单 我们从树顶开始

00:00:59.579 --> 00:01:00.979
选择任意可用赋值

00:01:00.979 --> 00:01:03.509
再沿着树下来 直到底部

00:01:03.509 --> 00:01:04.909
由于树是相容的

00:01:04.909 --> 00:01:07.539
所以任意变量赋值都能解出问题

00:01:07.540 --> 00:01:09.480
这个过程有多快呢？

00:01:09.480 --> 00:01:12.329
O(nd^2) 其中 n 仍是变量数

00:01:12.329 --> 00:01:14.310
d 是域的大小

00:01:14.310 --> 00:01:17.990
所以这个技巧果真能提高求解速度

00:01:17.989 --> 00:01:21.109
但如果约束图不是树状的呢？

00:01:21.109 --> 00:01:23.879
有时候你可以对问题进行调整

00:01:23.879 --> 00:01:24.920
通过为一些变量赋值

00:01:24.920 --> 00:01:26.659
将约束图改成树状的

00:01:28.000 --> 00:01:30.519
就像澳大利亚染色问题

00:01:30.519 --> 00:01:33.269
如果我们先为南澳大利亚赋值

00:01:33.269 --> 00:01:36.119
然后将该值从其邻地的可能值中排除

00:01:36.120 --> 00:01:37.460
那么问题就会变成树状的

00:01:37.459 --> 00:01:40.349
之后我们就可以用这个高效的办法来解问题了

00:01:40.349 --> 00:01:40.849
正是如此.最新课程跟课件还有一对一辅导请加wx：udacity6

