{
  "data": {
    "lesson": {
      "id": 556632,
      "key": "145113de-2cb1-4f79-8112-3270295b99a2",
      "title": "Solving Sudoku With AI",
      "semantic_type": "Lesson",
      "is_public": true,
      "version": "1.0.0",
      "locale": "en-us",
      "summary": "In this lesson, you'll dive right in and apply Artificial Intelligence to solve every Sudoku puzzle. ",
      "lesson_type": "Classroom",
      "display_workspace_project_only": null,
      "resources": {
        "files": [
          {
            "name": "Videos Zip File",
            "uri": "https://zips.udacity-data.com/145113de-2cb1-4f79-8112-3270295b99a2/556632/1538955080152/Solving+Sudoku+With+AI+Videos.zip"
          },
          {
            "name": "Transcripts Zip File",
            "uri": "https://zips.udacity-data.com/145113de-2cb1-4f79-8112-3270295b99a2/556632/1538955075481/Solving+Sudoku+With+AI+Subtitles.zip"
          }
        ],
        "google_plus_link": null,
        "career_resource_center_link": null,
        "coaching_appointments_link": null,
        "office_hours_link": null,
        "aws_provisioning_link": null
      },
      "project": null,
      "lab": null,
      "concepts": [
        {
          "id": 245253,
          "key": "74aac1e3-4ec8-4ab5-8279-9cfb2f220106",
          "title": "Intro",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "74aac1e3-4ec8-4ab5-8279-9cfb2f220106",
            "completed_at": "2020-05-28T19:04:39.880Z",
            "last_viewed_at": "2020-05-28T20:52:11.545Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 259087,
              "key": "d1cb16ec-c31a-4b0f-b2ad-f1ec7ea38c81",
              "title": "Intro",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "See Peter Norvig's great blog post on which this lesson is based [here](http://norvig.com/sudoku.html).",
              "video": {
                "youtube_id": "EuBLtVm85WY",
                "china_cdn_id": "EuBLtVm85WY.mp4"
              }
            }
          ]
        },
        {
          "id": 233428,
          "key": "7e6db44f-e00f-47d2-ae8b-88c6310e3295",
          "title": "Solving a Sudoku",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "7e6db44f-e00f-47d2-ae8b-88c6310e3295",
            "completed_at": "2020-05-28T20:58:51.218Z",
            "last_viewed_at": "2020-05-28T21:19:18.744Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 233438,
              "key": "c55e9195-44d0-4f41-8ad2-dff5497c3dfd",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## What is a Sudoku?\n\n[Sudoku](https://en.wikipedia.org/wiki/Sudoku) is one of the world's most popular puzzles. It consists of a 9x9 grid, and the objective is to fill the grid with digits in such a way that each row, each column, and each of the 9 principal 3x3 subsquares contains all of the digits from 1 to 9. The detailed rules can be found, for example, [here](http://www.conceptispuzzles.com/?uri=puzzle/sudoku/rules).\n\nThe puzzle is given as a partially completed grid, and the goal is to fill in the missing numbers. Below is an example of such a grid.",
              "instructor_notes": ""
            },
            {
              "id": 233439,
              "key": "32d40ed4-f559-4c7c-94d8-712f1e1dcb61",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586851cd_sudoku-easy/sudoku-easy.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/32d40ed4-f559-4c7c-94d8-712f1e1dcb61",
              "caption": "",
              "alt": null,
              "width": 1498,
              "height": 1348,
              "instructor_notes": null
            },
            {
              "id": 248119,
              "key": "61ec3e0e-cdc3-41bc-944c-3f09b6a58f52",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Goals of this project\n\nThe main goal of this project is to build an intelligent agent that will solve every sudoku while introducing you to two powerful techniques that are used throughout the field of AI:\n- **Constraint Propagation**<br />\nWhen trying to solve a problem, you'll find that there are some local constraints to each square. These constraints help you narrow the possibilities for the answer, which can be very helpful. We will learn to extract the maximum information out of these constraints in order to get closer to our solution. Additionally, you'll see how we can repeatedly apply simple constraints to iteratively narrow the search space of possible solutions. Constraint propagation can be used to solve a variety of problems such as calendar scheduling, and cryptographic puzzles.\n- **Search**<br />\nIn the process of problem solving, we may get to the point where two or more possibilities are available. What do we do? What if we branch out and consider both of them? Maybe one of them will lead us to a position in which three or more possibilities are available. Then, we can branch out again. At the end, we can create a whole tree of possibilities and find ways to traverse the tree until we find our solution. This is an example of how search can be used.\n\nThese ideas may seem simple and they're actually intended to be! Through this lesson you'll see how AI is really composed of very simple ideas that can be put together to solve complex problems. Throughout this lesson, we challenge you to think of how you can apply these ideas to build AI agents to solve other puzzles and problems in your world!",
              "instructor_notes": ""
            },
            {
              "id": 259387,
              "key": "470ec8df-418e-4f67-92fc-a63b156c396b",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Udacity Project Reviews\n\nAnother goal of this project is to get you familiarized with the submission process at Udacity. The AI Nanodegree program includes some self-graded exercises, some autograded exercises, and projects that are reviewed by one of our talented reviewers. The sudoku project is primarily autograded, although we have human reviewers available as backup. Most importantly, you'll be able to have fun as you use the power of AI to solve familiar problems and, in the process, compare how an AI agent thinks like a human!\n\n## Hands on!\n\nLet's get started by trying to solve a sudoku puzzle ourselves. Doing so will allow us to discover and become comfortable with the techniques that our agent may end up using.\n\nCopy down the Sudoku puzzle below and try to solve it. If you don't finish, it's ok. The solution is on the next page. But as you attempt to solve it, try to pick apart the techniques you use, as they may form part of your intelligent agent.\n\n_Ready? Pen? Paper? Let's go!_",
              "instructor_notes": ""
            },
            {
              "id": 259402,
              "key": "fe54d831-b535-4e7a-a908-35045e51b94c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/58852982_sudoku-easy/sudoku-easy.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/fe54d831-b535-4e7a-a908-35045e51b94c",
              "caption": "",
              "alt": null,
              "width": 1498,
              "height": 1348,
              "instructor_notes": null
            },
            {
              "id": 245250,
              "key": "6b2f3885-8bcb-4aca-b4bd-26b34ae8a306",
              "title": "Sudoku Quiz",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "6b2f3885-8bcb-4aca-b4bd-26b34ae8a306",
                "completed_at": "2020-05-28T21:19:32.566Z",
                "last_viewed_at": "2020-05-28T21:19:32.566Z",
                "unstructured": "{\"answer\":\"nm...\",\"is_correct\":false}"
              },
              "question": {
                "prompt": "Solve this sudoku! For the solution, please write the numbers as a string, formed by concatenating the rows from top to bottom with a `, ` (comma and a space). For example, if the top row is 123456789, and the next row is 456789123, then your solution must look like the string '123456789, 456789123, ...'.\n\n**Get out a pen and paper and copy down this grid to solve it!**",
                "matchers": [
                  {
                    "expression": "483921657, 967345821, 251876493, 548132976, 729564138, 136798245, 372689514, 814253769, 695417382"
                  },
                  {
                    "expression": "483921657,967345821,251876493,548132976,729564138,136798245,372689514,814253769,695417382"
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 245235,
          "key": "455259ab-540a-4e2e-b570-364eefab1241",
          "title": "Setting up the Board",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "455259ab-540a-4e2e-b570-364eefab1241",
            "completed_at": "2020-05-28T21:19:14.073Z",
            "last_viewed_at": "2020-05-30T04:46:53.809Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 245251,
              "key": "f54e9ba7-e71c-470b-8dd9-112805d22636",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Sudoku: Solution\n\nHere is the solution for the Sudoku.\n\nYour solution probably consisted of the following two steps (and maybe more):\n- If a box has a value, then all the boxes in the same row, same column, or same 3x3 square cannot have that same value.\n- If there is only one allowed value for a given box in a row, column, or 3x3 square, then the box is assigned that value.",
              "instructor_notes": ""
            },
            {
              "id": 245252,
              "key": "6e4f20da-040c-4bd9-af63-a7ce0a1bb0cd",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586c6bbd_sudoku-easy-solution/sudoku-easy-solution.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/6e4f20da-040c-4bd9-af63-a7ce0a1bb0cd",
              "caption": "",
              "alt": null,
              "width": 1503,
              "height": 1349,
              "instructor_notes": null
            },
            {
              "id": 245257,
              "key": "3e4fe73c-7fa4-46b8-991e-834f6397c9b7",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "# Naming Conventions\n## Rows and Columns\n\nSince we're writing an agent to solve the Sudoku puzzle, let's start by labelling rows and columns.\n- The rows will be labelled by the letters A, B, C, D, E, F, G, H, I.\n- The columns will be labelled by the numbers 1, 2, 3, 4, 5, 6, 7, 8, 9.\nHere we can see the unsolved and solved puzzles with the labels for the rows and columns.\n- The 3x3 squares won't be labelled, but in the diagram, they can be seen with alternating colors of grey and white.",
              "instructor_notes": ""
            },
            {
              "id": 245258,
              "key": "3fb2db5a-e22f-4e75-ae38-10260c4a64cc",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586c7a2a_labels/labels.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/3fb2db5a-e22f-4e75-ae38-10260c4a64cc",
              "caption": "",
              "alt": null,
              "width": 2190,
              "height": 925,
              "instructor_notes": null
            },
            {
              "id": 245261,
              "key": "0f416452-bf74-4088-8cd0-883bd2e08798",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "## Boxes, Units and Peers\n\nAnd let's start naming the important elements created by these rows and columns that are relevant to solving a Sudoku:\n- The individual squares at the intersection of rows and columns will be called `boxes`. These boxes will have labels 'A1', 'A2', ..., 'I9'.\n- The complete rows, columns, and 3x3 squares, will be called `units`. Thus, each unit is a set of 9 boxes, and there are 27 units in total.\n- For a particular box (such as 'A1'), its `peers` will be all other boxes that belong to a common unit (namely, those that belong to the same row, column, or 3x3 square).\n\nLet's see an example. In the grids below, the set of highlighted boxes represent `units`. Each grid shows a different `peer` of the box at E3.",
              "instructor_notes": ""
            },
            {
              "id": 247800,
              "key": "d6a6bc90-dadb-48b3-8a84-d096f3789030",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872f924_peers/peers.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/d6a6bc90-dadb-48b3-8a84-d096f3789030",
              "caption": "",
              "alt": null,
              "width": 2542,
              "height": 767,
              "instructor_notes": null
            },
            {
              "id": 245263,
              "key": "788b5d1f-1688-4189-84ac-0f35c80f9f77",
              "title": "Peers quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "788b5d1f-1688-4189-84ac-0f35c80f9f77",
                "completed_at": "2020-05-28T21:36:50.052Z",
                "last_viewed_at": "2020-05-28T21:37:11.448Z",
                "unstructured": "{\"selected_id\":\"a1483506631028\",\"is_correct\":true}"
              },
              "question": {
                "prompt": "Let's test your understanding!\nFor any box, how many peers are there?",
                "answers": [
                  {
                    "id": "a1483506590186",
                    "text": "18",
                    "is_correct": false
                  },
                  {
                    "id": "a1483506631028",
                    "text": "20",
                    "is_correct": true
                  },
                  {
                    "id": "a1483506634703",
                    "text": "27",
                    "is_correct": false
                  },
                  {
                    "id": "a1483506637806",
                    "text": "30",
                    "is_correct": false
                  }
                ]
              }
            }
          ]
        },
        {
          "id": 245259,
          "key": "f2c9405a-76ae-4616-bf2b-8e60fc9f6ac4",
          "title": "Encoding the Board",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "f2c9405a-76ae-4616-bf2b-8e60fc9f6ac4",
            "completed_at": "2020-05-28T21:37:15.008Z",
            "last_viewed_at": "2020-05-31T18:44:29.191Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 245265,
              "key": "30ca4b1e-32df-4eb1-a5cc-7a3b3c7da416",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586c861c_labels/labels.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/30ca4b1e-32df-4eb1-a5cc-7a3b3c7da416",
              "caption": "",
              "alt": null,
              "width": 2190,
              "height": 925,
              "instructor_notes": null
            },
            {
              "id": 245260,
              "key": "d8d2730e-74b8-43e1-b9ec-2ca11aea6b70",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now, in order to implement an agent, let's start by coding the board in Python. Then, we'll code the necessary functions to solve the Sudoku. We'll record the puzzles in two ways — as a `string` and as a `dictionary`.\n\nThe string will consist of a concatenation of all the readings of the digits in the rows, taking the rows from top to bottom. If the puzzle is not solved, we can use a `.` as a placeholder for an empty box.\n\nFor example, the unsolved puzzle at the above left will be written as:\n`..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..`\n\nAnd the solved puzzle at the above right, will be recorded as:\n`483921657967345821251876493548132976729564138136798245372689514814253769695417382`\n\nWe'll implement the dictionary as follows. The keys will be strings corresponding to the boxes — namely, `'A1'`, `'A2'`, ..., `'I9'`. The values will either be the digit in each box (if there is one) or a `'.'` (if not).\n\nSo, let's get started. First, we'll record rows and columns as strings.\n```python\nrows = 'ABCDEFGHI'\ncols = '123456789'\n```\n\nWe'll start by writing a helper function, `cross(a, b)`, which, given two strings — `a` and `b` — will return the list formed by all the possible concatenations of a letter `s` in string `a` with a letter `t` in string `b`.\n\nSo `cross('abc', 'def')` will return `['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf']`.\n\n```python\ndef cross(a, b):\n      return [s+t for s in a for t in b]\n```\nNow, to create the labels of the boxes:\n```python\nboxes = cross(rows, cols)\nboxes =\n    ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9',\n     'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9',\n     'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9',\n     'D1', 'D2', 'D3', 'D4', 'D5', 'D6', 'D7', 'D8', 'D9',\n     'E1', 'E2', 'E3', 'E4', 'E5', 'E6', 'E7', 'E8', 'E9',\n     'F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'F9',\n     'G1', 'G2', 'G3', 'G4', 'G5', 'G6', 'G7', 'G8', 'G9',\n     'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'H7', 'H8', 'H9',\n     'I1', 'I2', 'I3', 'I4', 'I5', 'I6', 'I7', 'I8', 'I9']\n```\nAnd for the units:\n```python\nrow_units = [cross(r, cols) for r in rows]\n# Element example:\n# row_units[0] = ['A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9']\n# This is the top most row.\n\ncolumn_units = [cross(rows, c) for c in cols]\n# Element example:\n# column_units[0] = ['A1', 'B1', 'C1', 'D1', 'E1', 'F1', 'G1', 'H1', 'I1']\n# This is the left most column.\n\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\n# Element example:\n# square_units[0] = ['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n# This is the top left square.\n\nunitlist = row_units + column_units + square_units\n```\n\nNow, we're ready to turn the string representation of a sudoku into a dictionary representation. That'll be your turn to shine!\n\n## Implement `grid_values()`\n### A function to convert the string representation of a puzzle into a dictionary form.\n\nRecall that for the string:\n```python\n'..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\n```\n...we'd like to return the dictionary:\n```python\n{\n  'A1': '.'\n  'A2': '.',\n  'A3': '3',\n  'A4': '.',\n  'A5': '2',\n  ...\n  'I9': '.'\n}\n```\n\nImplement a function called `grid_values()` that performs this task.\n\nFollowing is an example of what you should see when you implement this function correctly. The `display()` function shows a nice visual representation of the dictionary, and has been provided in `utils.py`.\n\n```python\n>>> from utils import display\n>>> display(grid_values('..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'))\n. . 3 |. 2 . |6 . . \n9 . . |3 . 5 |. . 1 \n. . 1 |8 . 6 |4 . . \n------+------+------\n. . 8 |1 . 2 |9 . . \n7 . . |. . . |. . 8 \n. . 6 |7 . 8 |2 . . \n------+------+------\n. . 2 |6 . 9 |5 . . \n8 . . |2 . 3 |. . 9 \n. . 5 |. 1 . |3 . . \n```\n\n**Note**:\n- All your code should go in `function.py`.\n- You can use the helper functions and variables defined in `utils.py`.\n- Hit **Test Run** to execute your code and **Submit** to verify it against our grader.\n- Once you're done, compare your implementation with ours in `solution.py`.\n\nGive it a shot!",
              "instructor_notes": ""
            },
            {
              "id": 257321,
              "key": "ea4870d3-652d-45d2-bc48-19b48503fcf1",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "ea4870d3-652d-45d2-bc48-19b48503fcf1",
                "completed_at": "2020-05-29T20:33:05.197Z",
                "last_viewed_at": "2020-05-29T21:08:44.580Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\n# `grid` is defined in the test code scope as the following:\\n# (note: changing the value here will _not_ change the test code)\\ngrid = '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\\n    \\\"\\\"\\\"\\n    grid_dict={}\\n    pointer = 0\\n    for element in grid:\\n        if element != None:\\n            grid_dict[boxes[pointer]]=element\\n            pointer+=1\\n    return grid_dict\\n            \\n\",\"utils.py\":\"rows = 'ABCDEFGHI'\\ncols = '123456789'\\n\\ndef cross(a, b):\\n    return [s+t for s in a for t in b]\\n\\nboxes = cross(rows, cols)\\n\\nrow_units = [cross(r, cols) for r in rows]\\ncolumn_units = [cross(rows, c) for c in cols]\\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\\nunitlist = row_units + column_units + square_units\\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\\n\\ndef display(values):\\n    \\\"\\\"\\\"\\n    Display the values as a 2-D grid.\\n    Input: The sudoku in dictionary form\\n    Output: None\\n    \\\"\\\"\\\"\\n    width = 1+max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-'*(width*3)]*3)\\n    for r in rows:\\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    return\\n\",\"solution.py\":\"from utils import *\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\\n    \\\"\\\"\\\"\\n    assert len(grid) == 81, \\\"Input grid must be a string of length 81 (9x9)\\\"\\n    return dict(zip(boxes, grid))\\n\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6051541954985984",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\n# `grid` is defined in the test code scope as the following:\n# (note: changing the value here will _not_ change the test code)\n# grid = '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\n\ndef grid_values(grid):\n    \"\"\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\n\n    Args:\n        grid: Sudoku grid in string form, 81 characters long\n    Returns:\n        Sudoku grid in dictionary form:\n        - keys: Box labels, e.g. 'A1'\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\n    \"\"\"\n    pass\n",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef grid_values(grid):\n    \"\"\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\n\n    Args:\n        grid: Sudoku grid in string form, 81 characters long\n    Returns:\n        Sudoku grid in dictionary form:\n        - keys: Box labels, e.g. 'A1'\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\n    \"\"\"\n    assert len(grid) == 81, \"Input grid must be a string of length 81 (9x9)\"\n    return dict(zip(boxes, grid))\n",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 247743,
          "key": "5a9169ef-3f43-425b-9f63-e39725fee4d1",
          "title": "Strategy 1: Elimination",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "5a9169ef-3f43-425b-9f63-e39725fee4d1",
            "completed_at": "2020-05-29T20:07:31.614Z",
            "last_viewed_at": "2020-06-08T22:34:04.153Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 247744,
              "key": "23bed8ff-d4b2-4400-87e6-7c16ef8cfce2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Insight: We can eliminate possible values for a box by looking at its peers\n\nOk, time to start solving the Sudoku!\n\nFirst things first, let's look at a box and analyze the values that could go in there.",
              "instructor_notes": ""
            },
            {
              "id": 247745,
              "key": "dc2d84cf-97ff-46e8-99b4-c8ee5b7d6485",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586dc35f_reduce-values/reduce-values.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/dc2d84cf-97ff-46e8-99b4-c8ee5b7d6485",
              "caption": "",
              "alt": null,
              "width": 1404,
              "height": 1295,
              "instructor_notes": null
            },
            {
              "id": 247746,
              "key": "14440127-697a-4d39-9298-d6510ae81d54",
              "title": "Only Choice Quiz",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "14440127-697a-4d39-9298-d6510ae81d54",
                "completed_at": "2020-05-29T20:09:05.433Z",
                "last_viewed_at": "2020-05-29T20:09:45.258Z",
                "unstructured": "{\"selected_ids\":[\"a1483913879074\",\"a1483913882027\"],\"is_correct\":true}"
              },
              "question": {
                "prompt": "What values are available for the red highlighted box in the puzzle above?",
                "answers": [
                  {
                    "id": "a1483913845951",
                    "text": "1",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913876271",
                    "text": "2",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913878155",
                    "text": "3",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913879074",
                    "text": "4",
                    "is_correct": true
                  },
                  {
                    "id": "a1483913879986",
                    "text": "5",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913881347",
                    "text": "6",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913882027",
                    "text": "7",
                    "is_correct": true
                  },
                  {
                    "id": "a1483913882734",
                    "text": "8",
                    "is_correct": false
                  },
                  {
                    "id": "a1483913883608",
                    "text": "9",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 247747,
              "key": "4a49d8ef-634b-4de5-a944-07fb81070f9a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "We can figure out the possible values for the red box using the following strategy.\n\n## Strategy 1: Elimination\n### If a box has a value assigned, then none of the peers of this box can have this value.",
              "instructor_notes": ""
            },
            {
              "id": 259090,
              "key": "98bd0e66-c784-4d9f-8229-e611cde76fec",
              "title": "Eliminate",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "6rFOX2jHB2g",
                "china_cdn_id": "6rFOX2jHB2g.mp4"
              }
            },
            {
              "id": 247749,
              "key": "727d78bc-05bc-4fcc-b2cd-7c08af05e741",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now that we know how to eliminate values, we can take one pass, go over every box that has a value, and eliminate the values that can't appear on the box, based on its peers. Once we do so, the board looks like this (for clarity, we've highlighted the original filled-in boxes in bold lettering):\n\n(Notice that if we take a second pass through the puzzle, we can gain even more information, but this is not necessary for now.)",
              "instructor_notes": ""
            },
            {
              "id": 247750,
              "key": "09c2bdc2-68fe-4087-bc0c-5650bfd3d521",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586dd40f_values-easy/values-easy.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/09c2bdc2-68fe-4087-bc0c-5650bfd3d521",
              "caption": "The possible values for every box. We can see here that the possible values for the original highlighted box are 4 and 7.",
              "alt": "",
              "width": 1503,
              "height": 1355,
              "instructor_notes": null
            },
            {
              "id": 247751,
              "key": "51bc3ca1-216b-4968-95db-b4840681f284",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "This seems like something we can code!\n\n## Improved `grid_values()`\n\nAs of now, we are recording the puzzles in dictionary form, where the keys are the boxes (`'A1', 'A2', ... , 'I9'`) and the values are either the value for each box (if a value exists) or `'.'` (if the box has no value assigned yet). What we really want is for each value to represent all the available values for that box. For example, the box in the second row and fifth column above will have key `'B5'` and value `'47'` (because `4` and `7` are the only possible values for it). The starting value for every empty box will thus be `'123456789'`.\n\nUpdate the `grid_values()` function to return `'123456789'` instead of `'.'` for empty boxes.",
              "instructor_notes": ""
            },
            {
              "id": 261429,
              "key": "c1858cef-2504-4528-bd32-7b9b9a22e5ec",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "c1858cef-2504-4528-bd32-7b9b9a22e5ec",
                "completed_at": "2020-05-29T20:51:36.860Z",
                "last_viewed_at": "2020-05-29T21:28:07.988Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\n# `grid` is defined in the test code scope as the following:\\n# (note: changing the value here will _not_ change the test code)\\ngrid = '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\\n    \\\"\\\"\\\"\\n    grid_dict={}\\n    pointer = 0\\n    for element in grid:\\n        if element != None:\\n            grid_dict[boxes[pointer]]=element\\n            pointer+=1\\n    grid_keys = grid_dict.keys()\\n    for key in grid_keys:\\n        if grid_dict.get(key) == '.':\\n            grid_dict.update({key: \\\"123456789\\\"})\\n    return grid_dict\",\"utils.py\":\"rows = 'ABCDEFGHI'\\ncols = '123456789'\\n\\ndef cross(a, b):\\n    return [s+t for s in a for t in b]\\n\\nboxes = cross(rows, cols)\\n\\nrow_units = [cross(r, cols) for r in rows]\\ncolumn_units = [cross(rows, c) for c in cols]\\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\\nunitlist = row_units + column_units + square_units\\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\\n\\ndef display(values):\\n    \\\"\\\"\\\"\\n    Display the values as a 2-D grid.\\n    Input: The sudoku in dictionary form\\n    Output: None\\n    \\\"\\\"\\\"\\n    width = 1+max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-'*(width*3)]*3)\\n    for r in rows:\\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    return\\n\",\"solution.py\":\"from utils import *\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '123456789' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '123456789' if it is empty.\\n    \\\"\\\"\\\"\\n    values = []\\n    all_digits = '123456789'\\n    for c in grid:\\n        if c == '.':\\n            values.append(all_digits)\\n        elif c in all_digits:\\n            values.append(c)\\n    assert len(values) == 81\\n    return dict(zip(boxes, values))\\n\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6101084738289664",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\ndef grid_values(grid):\n    \"\"\"Convert grid string into {<box>: <value>} dict with '123456789' value for empties.\n\n    Args:\n        grid: Sudoku grid in string form, 81 characters long\n    Returns:\n        Sudoku grid in dictionary form:\n        - keys: Box labels, e.g. 'A1'\n        - values: Value in corresponding box, e.g. '8', or '123456789' if it is empty.\n    \"\"\"\n    pass\n",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef grid_values(grid):\n    \"\"\"Convert grid string into {<box>: <value>} dict with '123456789' value for empties.\n\n    Args:\n        grid: Sudoku grid in string form, 81 characters long\n    Returns:\n        Sudoku grid in dictionary form:\n        - keys: Box labels, e.g. 'A1'\n        - values: Value in corresponding box, e.g. '8', or '123456789' if it is empty.\n    \"\"\"\n    values = []\n    all_digits = '123456789'\n    for c in grid:\n        if c == '.':\n            values.append(all_digits)\n        elif c in all_digits:\n            values.append(c)\n    assert len(values) == 81\n    return dict(zip(boxes, values))\n",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 261427,
              "key": "e5367d8a-2cb8-4dea-a75c-50dad5725c92",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So, from now on, we'll think of the puzzles in this way. Thus, the puzzle in the last section will look like this (in dictionary form):\n```python\n{\n    'A1': '123456789',\n    'A2': '123456789',\n    'A3': '3',\n    'A4': '123456789'\n    'A5': '2',\n    ...\n    'I9': '123456789'\n}\n```\n\n## Implement `eliminate()`\nNow, let's finish the code for the function `eliminate()`, which will take as input a puzzle in dictionary form. The function will iterate over all the boxes in the puzzle that only have one value assigned to them, and it will remove this value from every one of its peers.",
              "instructor_notes": ""
            },
            {
              "id": 247752,
              "key": "d4da8506-5eaa-4132-b0ba-6b32bfa5bd25",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "d4da8506-5eaa-4132-b0ba-6b32bfa5bd25",
                "completed_at": "2020-05-29T21:09:03.792Z",
                "last_viewed_at": "2020-06-08T22:35:06.679Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\n# `grid` is defined in the test code scope as the following:\\n# (note: changing the value here will _not_ change the test code)\\ngrid = '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\\n    \\\"\\\"\\\"\\n    grid_dict = {}\\n    pointer = 0\\n    for element in grid:\\n        if element != None:\\n            grid_dict[boxes[pointer]] = element\\n            pointer += 1\\n    grid_keys = grid_dict.keys()\\n    for key in grid_keys:\\n        if grid_dict.get(key) == '.':\\n            grid_dict.update({key: \\\"123456789\\\"})\\n\\n    return grid_dict\\n    \\n\\n\\n\\ndef eliminate(values):\\n    \\\"\\\"\\\"Eliminate values from peers of each box with a single value.\\n\\n    Go through all the boxes, and whenever there is a box with a single value,\\n    eliminate this value from the set of values of all its peers.\\n\\n    Args:\\n        values: Sudoku in dictionary form.\\n    Returns:\\n        Resulting Sudoku in dictionary form after eliminating values.\\n    \\\"\\\"\\\"\\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\\n    for box in solved_values:\\n        digit = values[box]\\n        for peer in peers[box]:\\n            values[peer] = values[peer].replace(digit,'')\\n    return values\\n    \\ngrid = grid_values(grid)    \\nvalues = eliminate(grid)\\ndisplay(values)\\n\",\"utils.py\":\"rows = 'ABCDEFGHI'\\ncols = '123456789'\\n\\ndef cross(a, b):\\n    return [s+t for s in a for t in b]\\n\\n\\nboxes = cross(rows, cols)\\n\\nrow_units = [cross(r, cols) for r in rows]\\ncolumn_units = [cross(rows, c) for c in cols]\\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\\nunitlist = row_units + column_units + square_units\\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\\n\\n\\ndef display(values):\\n    \\\"\\\"\\\"\\n    Display the values as a 2-D grid.\\n    Input: The sudoku in dictionary form\\n    Output: None\\n    \\\"\\\"\\\"\\n    width = 1+max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-'*(width*3)]*3)\\n    for r in rows:\\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    return\\n\\n\\n# WARNING! We've modified this function to return '123456789' instead of '.' for boxes with no value.\\n# Look at the explanation above in the text.\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '123456789' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '123456789' if it is empty.\\n    \\\"\\\"\\\"\\n    values = []\\n    all_digits = '123456789'\\n    for c in grid:\\n        if c == '.':\\n            values.append(all_digits)\\n        elif c in all_digits:\\n            values.append(c)\\n    assert len(values) == 81\\n    return dict(zip(boxes, values))\\n\",\"solution.py\":\"from utils import *\\n\\ndef eliminate(values):\\n    \\\"\\\"\\\"Eliminate values from peers of each box with a single value.\\n\\n    Go through all the boxes, and whenever there is a box with a single value,\\n    eliminate this value from the set of values of all its peers.\\n\\n    Args:\\n        values: Sudoku in dictionary form.\\n    Returns:\\n        Resulting Sudoku in dictionary form after eliminating values.\\n    \\\"\\\"\\\"\\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\\n    for box in solved_values:\\n        digit = values[box]\\n        for peer in peers[box]:\\n            values[peer] = values[peer].replace(digit,'')\\n    return values\\n\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5978451786989568",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\ndef eliminate(values):\n    \"\"\"Eliminate values from peers of each box with a single value.\n\n    Go through all the boxes, and whenever there is a box with a single value,\n    eliminate this value from the set of values of all its peers.\n\n    Args:\n        values: Sudoku in dictionary form.\n    Returns:\n        Resulting Sudoku in dictionary form after eliminating values.\n    \"\"\"\n    pass",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n\n\n# WARNING! We've modified this function to return '123456789' instead of '.' for boxes with no value.\n# Look at the explanation above in the text.\ndef grid_values(grid):\n    \"\"\"Convert grid string into {<box>: <value>} dict with '123456789' value for empties.\n\n    Args:\n        grid: Sudoku grid in string form, 81 characters long\n    Returns:\n        Sudoku grid in dictionary form:\n        - keys: Box labels, e.g. 'A1'\n        - values: Value in corresponding box, e.g. '8', or '123456789' if it is empty.\n    \"\"\"\n    values = []\n    all_digits = '123456789'\n    for c in grid:\n        if c == '.':\n            values.append(all_digits)\n        elif c in all_digits:\n            values.append(c)\n    assert len(values) == 81\n    return dict(zip(boxes, values))\n",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef eliminate(values):\n    \"\"\"Eliminate values from peers of each box with a single value.\n\n    Go through all the boxes, and whenever there is a box with a single value,\n    eliminate this value from the set of values of all its peers.\n\n    Args:\n        values: Sudoku in dictionary form.\n    Returns:\n        Resulting Sudoku in dictionary form after eliminating values.\n    \"\"\"\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\n    for box in solved_values:\n        digit = values[box]\n        for peer in peers[box]:\n            values[peer] = values[peer].replace(digit,'')\n    return values\n",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 245240,
          "key": "dd16929d-4d9b-4b6a-b7ed-eb9871b4c3a1",
          "title": "Strategy 2: Only Choice",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "dd16929d-4d9b-4b6a-b7ed-eb9871b4c3a1",
            "completed_at": "2020-05-30T02:10:52.873Z",
            "last_viewed_at": "2020-06-08T22:39:05.152Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 247754,
              "key": "a6c2272f-0eab-4bf4-86d9-cdf4f5d1500a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Insight: Every unit must contain exactly one occurrence of every number\nSo, these are the values we obtain when we apply the function `eliminate`.",
              "instructor_notes": ""
            },
            {
              "id": 247755,
              "key": "933bb70c-b88a-4d10-ada6-4ab9f2d949e8",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/586dd40f_values-easy/values-easy.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/933bb70c-b88a-4d10-ada6-4ab9f2d949e8",
              "caption": "",
              "alt": null,
              "width": 1503,
              "height": 1355,
              "instructor_notes": null
            },
            {
              "id": 247756,
              "key": "3ea8aef7-68f3-46eb-ac35-e510e598413f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Let's actually look more carefully at the top 3x3 square in the center, highlighted in red.\n<end video>",
              "instructor_notes": ""
            },
            {
              "id": 1079259,
              "key": "fa7ddd2b-c0cc-45b8-9d52-f238e3eda78e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2020/September/5f6be3e2_screen-shot-2020-09-23-at-5.09.11-pm/screen-shot-2020-09-23-at-5.09.11-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/fa7ddd2b-c0cc-45b8-9d52-f238e3eda78e",
              "caption": "",
              "alt": "",
              "width": 498,
              "height": 445,
              "instructor_notes": null
            },
            {
              "id": 247758,
              "key": "8908b03c-2d9c-47e2-a84a-df9dc3043e1c",
              "title": "Single possibility quiz",
              "semantic_type": "CheckboxQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "8908b03c-2d9c-47e2-a84a-df9dc3043e1c",
                "completed_at": "2020-05-30T02:12:34.247Z",
                "last_viewed_at": "2020-05-30T02:13:24.845Z",
                "unstructured": "{\"selected_ids\":[\"a1483915137714\"],\"is_correct\":true}"
              },
              "question": {
                "prompt": "Looking at the unsolved boxes in the red 3x3 square, which of the below values can we fill in, based **only** on the other values in this unit? Select all the values that apply.",
                "answers": [
                  {
                    "id": "a1483915137714",
                    "text": "1",
                    "is_correct": true
                  },
                  {
                    "id": "a1483915177656",
                    "text": "2",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915178653",
                    "text": "3",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915179712",
                    "text": "4",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915180285",
                    "text": "5",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915181035",
                    "text": "6",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915181733",
                    "text": "7",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915182504",
                    "text": "8",
                    "is_correct": false
                  },
                  {
                    "id": "a1483915183287",
                    "text": "9",
                    "is_correct": false
                  }
                ]
              }
            },
            {
              "id": 259091,
              "key": "f39fa802-3c22-468a-ad47-2bad7704704b",
              "title": "Only Choice",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "sSjYn-Kex1A",
                "china_cdn_id": "sSjYn-Kex1A.mp4"
              }
            },
            {
              "id": 247760,
              "key": "0ef400f8-920d-420a-8ac0-180e9c55a45f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So, we have another strategy!\n# Strategy 2: Only Choice\n### If there is only one box in a unit which would allow a certain digit, then that box must be assigned that digit.\n\nTime to code it! In the next quiz, finish the code for the function `only_choice`, which will take as input a puzzle in dictionary form. The function will go through all the units, and if there is a unit with a digit that only fits in one possible box, it will assign that digit to that box.",
              "instructor_notes": ""
            },
            {
              "id": 261268,
              "key": "93ba75de-ec33-4c7f-a1f9-1aeb650731ea",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5887d815_only-choice/only-choice.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/93ba75de-ec33-4c7f-a1f9-1aeb650731ea",
              "caption": "The above image shows the result of applying the only choice rule.",
              "alt": null,
              "width": 874,
              "height": 312,
              "instructor_notes": null
            },
            {
              "id": 246624,
              "key": "c2f171fd-cc96-4b4d-9b87-2b1443b39583",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "c2f171fd-cc96-4b4d-9b87-2b1443b39583",
                "completed_at": "2020-05-30T02:42:03.154Z",
                "last_viewed_at": "2020-06-08T22:39:40.015Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\n# `grid` is defined in the test code scope as the following:\\n# (note: changing the value here will _not_ change the test code)\\ngrid = '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..'\\n\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"Convert grid string into {<box>: <value>} dict with '.' value for empties.\\n\\n    Args:\\n        grid: Sudoku grid in string form, 81 characters long\\n    Returns:\\n        Sudoku grid in dictionary form:\\n        - keys: Box labels, e.g. 'A1'\\n        - values: Value in corresponding box, e.g. '8', or '.' if it is empty.\\n    \\\"\\\"\\\"\\n    grid_dict = {}\\n    pointer = 0\\n    for element in grid:\\n        if element != None:\\n            grid_dict[boxes[pointer]] = element\\n            pointer += 1\\n    grid_keys = grid_dict.keys()\\n    for key in grid_keys:\\n        if grid_dict.get(key) == '.':\\n            grid_dict.update({key: \\\"123456789\\\"})\\n\\n    return grid_dict\\n\\ndef eliminate(values):\\n    \\\"\\\"\\\"Eliminate values from peers of each box with a single value.\\n\\n    Go through all the boxes, and whenever there is a box with a single value,\\n    eliminate this value from the set of values of all its peers.\\n\\n    Args:\\n        values: Sudoku in dictionary form.\\n    Returns:\\n        Resulting Sudoku in dictionary form after eliminating values.\\n    \\\"\\\"\\\"\\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\\n    for box in solved_values:\\n        digit = values[box]\\n        for peer in peers[box]:\\n            values[peer] = values[peer].replace(digit,'')\\n    return values\\n\\ndef only_choice(values):\\n    \\\"\\\"\\\"Apply the only choice strategy to a Sudoku puzzle\\n\\n    The only choice strategy says that if only one box in a unit allows a certain\\n    digit, then that box must be assigned that digit.\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    Returns\\n    -------\\n    dict\\n        The values dictionary with all single-valued boxes assigned\\n\\n    Notes\\n    -----\\n    You should be able to complete this function by copying your code from the classroom\\n    \\\"\\\"\\\"\\n    # TODO: Copy your code from the classroom to complete this function\\n    #raise NotImplementedError\\n    #unit = [[row],[col],[unit]]\\n    #peer = element in [row], [col]  eg.'A1'\\n    #to_change = the element has only choice: '123' -> '1'\\n    for unit in unitlist:\\n        for digit in '123456789':\\n            count = 0\\n            for peer in unit:\\n                if digit in values[peer]:\\n                    count += 1\\n            if count == 1:\\n                to_change = [box for box in unit if digit in values[box]]\\n                #print(unit)\\n                for element in to_change:\\n                    values[element] = digit\\n    return values\\n\\n\",\"utils.py\":\"rows = 'ABCDEFGHI'\\ncols = '123456789'\\n\\ndef cross(a, b):\\n    return [s+t for s in a for t in b]\\n\\nboxes = cross(rows, cols)\\n\\nrow_units = [cross(r, cols) for r in rows]\\ncolumn_units = [cross(rows, c) for c in cols]\\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\\nunitlist = row_units + column_units + square_units\\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\\n\\ndef display(values):\\n    \\\"\\\"\\\"\\n    Display the values as a 2-D grid.\\n    Input: The sudoku in dictionary form\\n    Output: None\\n    \\\"\\\"\\\"\\n    width = 1+max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-'*(width*3)]*3)\\n    for r in rows:\\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    return\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"\\n    Convert grid into a dict of {square: char} with '123456789' for empties.\\n    Input: A grid in string form.\\n    Output: A grid in dictionary form\\n            Keys: The boxes, e.g., 'A1'\\n            Values: The value in each box, e.g., '8'. If the box has no value, then the value will be '123456789'.\\n    \\\"\\\"\\\"\\n    chars = []\\n    digits = '123456789'\\n    for c in grid:\\n        if c in digits:\\n            chars.append(c)\\n        if c == '.':\\n            chars.append(digits)\\n    assert len(chars) == 81\\n    return dict(zip(boxes, chars))\\n\",\"solution.py\":\"from utils import *\\n\\ndef only_choice(values):\\n    \\\"\\\"\\\"Finalize all values that are the only choice for a unit.\\n\\n    Go through all the units, and whenever there is a unit with a value\\n    that only fits in one box, assign the value to this box.\\n\\n    Input: Sudoku in dictionary form.\\n    Output: Resulting Sudoku in dictionary form after filling in only choices.\\n    \\\"\\\"\\\"\\n    for unit in unitlist:\\n        for digit in '123456789':\\n            dplaces = [box for box in unit if digit in values[box]]\\n            if len(dplaces) == 1:\\n                values[dplaces[0]] = digit\\n    return values\\n\\n\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "6496564227997696",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\ndef only_choice(values):\n    \"\"\"Finalize all values that are the only choice for a unit.\n\n    Go through all the units, and whenever there is a unit with a value\n    that only fits in one box, assign the value to this box.\n\n    Input: Sudoku in dictionary form.\n    Output: Resulting Sudoku in dictionary form after filling in only choices.\n    \"\"\"\n    # TODO: Implement only choice strategy here\n    return values\n",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n\ndef grid_values(grid):\n    \"\"\"\n    Convert grid into a dict of {square: char} with '123456789' for empties.\n    Input: A grid in string form.\n    Output: A grid in dictionary form\n            Keys: The boxes, e.g., 'A1'\n            Values: The value in each box, e.g., '8'. If the box has no value, then the value will be '123456789'.\n    \"\"\"\n    chars = []\n    digits = '123456789'\n    for c in grid:\n        if c in digits:\n            chars.append(c)\n        if c == '.':\n            chars.append(digits)\n    assert len(chars) == 81\n    return dict(zip(boxes, chars))\n",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef only_choice(values):\n    \"\"\"Finalize all values that are the only choice for a unit.\n\n    Go through all the units, and whenever there is a unit with a value\n    that only fits in one box, assign the value to this box.\n\n    Input: Sudoku in dictionary form.\n    Output: Resulting Sudoku in dictionary form after filling in only choices.\n    \"\"\"\n    for unit in unitlist:\n        for digit in '123456789':\n            dplaces = [box for box in unit if digit in values[box]]\n            if len(dplaces) == 1:\n                values[dplaces[0]] = digit\n    return values\n",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            }
          ]
        },
        {
          "id": 247761,
          "key": "ad87e9e8-3b7f-42ab-bbba-f5b28cb80ca4",
          "title": "Constraint Propagation",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ad87e9e8-3b7f-42ab-bbba-f5b28cb80ca4",
            "completed_at": "2020-05-30T02:36:45.022Z",
            "last_viewed_at": "2020-06-09T02:18:20.184Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 259393,
              "key": "9c09a435-fa6c-4601-9720-eda4f06f78ea",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Constraint Propagation\n\nIf you've made it this far, you've already gained hands on exposure to a powerful technique in AI - Constraint Propagation. Constraint Propagation is all about using local constraints in a space (in the case of Sudoku, the constraints of each square) to dramatically reduce the search space. As we enforce each constraint, we see how it introduces new constraints for other parts of the board that can help us further reduce the number of possibilities. We have an entire lesson devoted to Constraint Propagation but let's quickly see some other famous AI problems it helps us solve.\n\n##### Map Coloring\n",
              "instructor_notes": ""
            },
            {
              "id": 259394,
              "key": "709af3c8-867d-4b62-9be0-0f3940d78499",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/587400ff_map-coloring/map-coloring.jpg",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/709af3c8-867d-4b62-9be0-0f3940d78499",
              "caption": "No two adjacent items can be the same color in the map coloring problem.",
              "alt": null,
              "width": 949,
              "height": 548,
              "instructor_notes": null
            },
            {
              "id": 259395,
              "key": "52fae405-23e3-4333-bbf8-61d0d2635d25",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In the map coloring problem, we must find a way to color the map such that no two adjacent items share the same color. Indeed, we'll see how we use constraint propagation to use this simple constraint to find a solution just as we use such constraints to solve Sudoku.",
              "instructor_notes": ""
            },
            {
              "id": 259396,
              "key": "2cbf675a-ea8d-4790-b382-fdda28bbc768",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "##### Crypto-Arithmetic Puzzles",
              "instructor_notes": ""
            },
            {
              "id": 259397,
              "key": "0588ed8e-d296-48b1-9948-a794401f9382",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/58851414_screen-shot-2017-01-22-at-12.20.03-pm/screen-shot-2017-01-22-at-12.20.03-pm.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/0588ed8e-d296-48b1-9948-a794401f9382",
              "caption": "In the above, what digits do T, W, O, F, U, and R represent?",
              "alt": null,
              "width": 1800,
              "height": 1134,
              "instructor_notes": null
            },
            {
              "id": 259398,
              "key": "a4aa1d42-1d5c-4f77-bc3d-c5091410f29a",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "In Crypto-Arithmetic puzzles, each letter represents a digit, and no two letters represent the same digit. None of the numbers start with a leading zero. Our goal is to find a mapping from letters to digits that satisfies the equations. Here again, we'll find that the constraints imposed by the equation allow us to create an intelligent algorithm to solve the problem via Constraint Propagation.\n",
              "instructor_notes": ""
            },
            {
              "id": 259399,
              "key": "c50aa7d2-7a1f-479b-8e18-1b90f050fd03",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Applying Constraint Propagation to Sudoku",
              "instructor_notes": ""
            },
            {
              "id": 259092,
              "key": "f3265c85-8b8c-4ae3-ba26-8ccc3e7640ff",
              "title": "Constraint Propagation",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "aSYDBcbvC5Y",
                "china_cdn_id": "aSYDBcbvC5Y.mp4"
              }
            },
            {
              "id": 247764,
              "key": "1bb4d932-eb63-40cd-be63-b0406909f80e",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Now that you see how we apply Constraint Propagation to this problem, let's try to code it! In the following quiz, combine the functions `eliminate` and `only_choice` to write the function `reduce_puzzle`, which receives as input an unsolved puzzle and applies our two constraints repeatedly in an attempt to solve it.\n\nSome things to watch out for:\n- The function needs to stop if the puzzle gets solved. How to do this?\n- What if the function doesn't solve the sudoku? Can we make sure the function quits when applying the two strategies stops making progress?\n",
              "instructor_notes": ""
            },
            {
              "id": 247765,
              "key": "7dbc753a-80cb-4d1e-a415-2a67d7ce7fe2",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "7dbc753a-80cb-4d1e-a415-2a67d7ce7fe2",
                "completed_at": "2020-06-01T00:06:54.462Z",
                "last_viewed_at": "2020-06-09T01:44:06.846Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\ndef reduce_puzzle(values):\\n    \\\"\\\"\\\"Reduce a Sudoku puzzle by repeatedly applying all constraint strprint(peer)ategies\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    Returns\\n    -------\\n    dict or False\\n        The values dictionary after continued application of the constraint strategies\\n        no longer produces any changes, or False if the puzzle is unsolvable\\n    \\\"\\\"\\\"\\n    # TODO: Copy your code from the classroom and modify it to complete this function\\n    #raise NotImplementedError\\n    boxes = values.keys()\\n    box_before = [box for box in boxes if len(values[box])==1]\\n    #values = naked_twins(values)\\n    values = eliminate(values)\\n    values = only_choice(values)\\n    display(values)\\n    for box in boxes:\\n        if values[box] == '':\\n            return False\\n    box_after = [box for box in boxes if len(values[box])==1]\\n    if len(box_before) == len(box_after):\\n        return values\\n    return reduce_puzzle(values)\\n\",\"utils.py\":\"rows = 'ABCDEFGHI'\\ncols = '123456789'\\n\\ndef cross(a, b):\\n    return [s+t for s in a for t in b]\\n\\nboxes = cross(rows, cols)\\n\\nrow_units = [cross(r, cols) for r in rows]\\ncolumn_units = [cross(rows, c) for c in cols]\\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\\nunitlist = row_units + column_units + square_units\\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\\n\\ndef display(values):\\n    \\\"\\\"\\\"\\n    Display the values as a 2-D grid.\\n    Input: The sudoku in dictionary form\\n    Output: None\\n    \\\"\\\"\\\"\\n    width = 1+max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-'*(width*3)]*3)\\n    for r in rows:\\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    return\\n\\ndef grid_values(grid):\\n    \\\"\\\"\\\"\\n    Convert grid into a dict of {square: char} with '123456789' for empties.\\n    Input: A grid in string form.\\n    Output: A grid in dictionary form\\n            Keys: The boxes, e.g., 'A1'\\n            Values: The value in each box, e.g., '8'. If the box has no value, then the value will be '123456789'.\\n    \\\"\\\"\\\"\\n    chars = []\\n    digits = '123456789'\\n    for c in grid:\\n        if c in digits:\\n            chars.append(c)\\n        if c == '.':\\n            chars.append(digits)\\n    assert len(chars) == 81\\n    return dict(zip(boxes, chars))\\n    \\ndef eliminate(values):\\n    \\\"\\\"\\\"\\n    Go through all the boxes, and whenever there is a box with a value, eliminate this value from the values of all its peers.\\n    Input: A sudoku in dictionary form.\\n    Output: The resulting sudoku in dictionary form.\\n    \\\"\\\"\\\"\\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\\n    for box in solved_values:\\n        digit = values[box]\\n        for peer in peers[box]:\\n            values[peer] = values[peer].replace(digit,'')\\n    return values\\n\\ndef only_choice(values):\\n    \\\"\\\"\\\"\\n    Go through all the units, and whenever there is a unit with a value that only fits in one box, assign the value to this box.\\n    Input: A sudoku in dictionary form.\\n    Output: The resulting sudoku in dictionary form.\\n    \\\"\\\"\\\"\\n    for unit in unitlist:\\n        for digit in '123456789':\\n            dplaces = [box for box in unit if digit in values[box]]\\n            if len(dplaces) == 1:\\n                values[dplaces[0]] = digit\\n    return values\",\"solution.py\":\"from utils import *\\n\\ndef reduce_puzzle(values):\\n    \\\"\\\"\\\"\\n    Iterate eliminate() and only_choice(). If at some point, there is a box with no available values, return False.\\n    If the sudoku is solved, return the sudoku.\\n    If after an iteration of both functions, the sudoku remains the same, return the sudoku.\\n    Input: A sudoku in dictionary form.\\n    Output: The resulting sudoku in dictionary form.\\n    \\\"\\\"\\\"\\n    stalled = False\\n    while not stalled:\\n        # Check how many boxes have a determined value\\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\\n        # Use the Eliminate Strategy\\n        values = eliminate(values)\\n        # Use the Only Choice Strategy\\n        values = only_choice(values)\\n        # Check how many boxes have a determined value, to compare\\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\\n        # If no new values were added, stop the loop.\\n        stalled = solved_values_before == solved_values_after\\n        # Sanity check, return False if there is a box with zero available values:\\n        if len([box for box in values.keys() if len(values[box]) == 0]):\\n            return False\\n    return values\\n\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "4935453875765248",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\ndef reduce_puzzle(values):\n    stalled = False\n    while not stalled:\n        # Check how many boxes have a determined value\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\n\n        # Your code here: Use the Eliminate Strategy\n\n        # Your code here: Use the Only Choice Strategy\n\n        # Check how many boxes have a determined value, to compare\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\n        # If no new values were added, stop the loop.\n        stalled = solved_values_before == solved_values_after\n        # Sanity check, return False if there is a box with zero available values:\n        if len([box for box in values.keys() if len(values[box]) == 0]):\n            return False\n    return values\n",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n\ndef grid_values(grid):\n    \"\"\"\n    Convert grid into a dict of {square: char} with '123456789' for empties.\n    Input: A grid in string form.\n    Output: A grid in dictionary form\n            Keys: The boxes, e.g., 'A1'\n            Values: The value in each box, e.g., '8'. If the box has no value, then the value will be '123456789'.\n    \"\"\"\n    chars = []\n    digits = '123456789'\n    for c in grid:\n        if c in digits:\n            chars.append(c)\n        if c == '.':\n            chars.append(digits)\n    assert len(chars) == 81\n    return dict(zip(boxes, chars))\n    \ndef eliminate(values):\n    \"\"\"\n    Go through all the boxes, and whenever there is a box with a value, eliminate this value from the values of all its peers.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\n    for box in solved_values:\n        digit = values[box]\n        for peer in peers[box]:\n            values[peer] = values[peer].replace(digit,'')\n    return values\n\ndef only_choice(values):\n    \"\"\"\n    Go through all the units, and whenever there is a unit with a value that only fits in one box, assign the value to this box.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    for unit in unitlist:\n        for digit in '123456789':\n            dplaces = [box for box in unit if digit in values[box]]\n            if len(dplaces) == 1:\n                values[dplaces[0]] = digit\n    return values",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef reduce_puzzle(values):\n    \"\"\"\n    Iterate eliminate() and only_choice(). If at some point, there is a box with no available values, return False.\n    If the sudoku is solved, return the sudoku.\n    If after an iteration of both functions, the sudoku remains the same, return the sudoku.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    stalled = False\n    while not stalled:\n        # Check how many boxes have a determined value\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\n        # Use the Eliminate Strategy\n        values = eliminate(values)\n        # Use the Only Choice Strategy\n        values = only_choice(values)\n        # Check how many boxes have a determined value, to compare\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\n        # If no new values were added, stop the loop.\n        stalled = solved_values_before == solved_values_after\n        # Sanity check, return False if there is a box with zero available values:\n        if len([box for box in values.keys() if len(values[box]) == 0]):\n            return False\n    return values\n",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 259429,
              "key": "914db0b5-706a-4176-bb12-1b21892ddf0f",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So, that seemed to work! You should have got this answer.",
              "instructor_notes": ""
            },
            {
              "id": 259430,
              "key": "6c7844e1-a283-4513-b596-b8a64538c47a",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5885b51c_easy-solution/easy-solution.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/6c7844e1-a283-4513-b596-b8a64538c47a",
              "caption": "",
              "alt": null,
              "width": 1502,
              "height": 1355,
              "instructor_notes": null
            }
          ]
        },
        {
          "id": 245242,
          "key": "2dce3a11-ad7f-4813-8022-5d494b4c353d",
          "title": "Harder Sudoku",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "2dce3a11-ad7f-4813-8022-5d494b4c353d",
            "completed_at": "2020-05-30T02:36:44.488Z",
            "last_viewed_at": "2020-06-09T01:43:00.631Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 247767,
              "key": "a2355424-09dd-462d-aeff-5928df48db02",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Harder Sudoku\n\nOk, let's see if our algorithm will work all the time. Here's a harder sudoku puzzle:",
              "instructor_notes": ""
            },
            {
              "id": 247768,
              "key": "2a5d16d3-cd39-4168-b96b-91c010888988",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872c76b_harder-puzzle/harder-puzzle.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/2a5d16d3-cd39-4168-b96b-91c010888988",
              "caption": "",
              "alt": null,
              "width": 1420,
              "height": 1294,
              "instructor_notes": null
            },
            {
              "id": 247736,
              "key": "d7186e71-7367-4b6e-9559-b09c84de1bfa",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "```\ngrid2 = '4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......'\nvalues = grid_values(grid2)\n```\nWhen we apply `reduce_puzzle`, we get the following grid:",
              "instructor_notes": ""
            },
            {
              "id": 247770,
              "key": "5282a34c-b3c2-45b1-a781-674c46d4b9cf",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872c7c8_harder-sudoku-reduced/harder-sudoku-reduced.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/5282a34c-b3c2-45b1-a781-674c46d4b9cf",
              "caption": "",
              "alt": null,
              "width": 1412,
              "height": 1287,
              "instructor_notes": null
            },
            {
              "id": 247771,
              "key": "6742e945-eb7b-4eb9-b8b9-b6092f356db2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Oh no! The algorithm didn't solve it. It seemed to reduce every box to a number of possibilites, but it won't go farther than that. We need to think of other ways to improve our solution.",
              "instructor_notes": ""
            }
          ]
        },
        {
          "id": 245243,
          "key": "ca7b0785-1617-4c7a-bfc1-47c285562c79",
          "title": "Strategy 3: Search",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "ca7b0785-1617-4c7a-bfc1-47c285562c79",
            "completed_at": "2020-05-30T02:36:42.500Z",
            "last_viewed_at": "2020-06-09T01:50:59.173Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 247772,
              "key": "f1f5513e-6819-4594-a94e-73d628089787",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Search",
              "instructor_notes": ""
            },
            {
              "id": 259425,
              "key": "dcea5d5f-0cdf-4879-b66d-78fab34730f9",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5885ac6f_screen-shot-2017-01-22-at-11.08.01-pm-1/screen-shot-2017-01-22-at-11.08.01-pm-1.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/dcea5d5f-0cdf-4879-b66d-78fab34730f9",
              "caption": "An example of Search being used in Google's AlphaGo [paper](https://storage.googleapis.com/deepmind-media/alphago/AlphaGoNaturePaper.pdf).",
              "alt": null,
              "width": 1242,
              "height": 420,
              "instructor_notes": null
            },
            {
              "id": 259424,
              "key": "5156e900-e37b-4ec8-bcd1-abe0d06062cb",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "\nWe're now going to use another foundational AI technique to help us solve this problem: Search.\n\nSearch is used throughout AI from Game-Playing to Route Planning to efficiently find solutions.\n\nHere's how we'll apply it. The box `'A2'` has four possibilities: 1, 6, 7, and 9. Why don't we fill it in with a 1 and try to solve our puzzle. If we can't solve it, we'll try with a 6, then with a 7, and then with a 9. Sure, it's four times as much work, but each one of the cases becomes easier.\n\nActually, there's something a bit smarter than that. Looking carefully at the puzzle, is there a better choice for a box than `'A2'`?\n",
              "instructor_notes": ""
            },
            {
              "id": 247773,
              "key": "2bbedf98-8ddd-40f2-9292-6111b72c6215",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872cbd3_choices/choices.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/2bbedf98-8ddd-40f2-9292-6111b72c6215",
              "caption": "",
              "alt": null,
              "width": 1404,
              "height": 1278,
              "instructor_notes": null
            },
            {
              "id": 247775,
              "key": "a217d14f-fa23-43d1-986f-c93e995c210d",
              "title": "Choice quiz",
              "semantic_type": "RadioQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "a217d14f-fa23-43d1-986f-c93e995c210d",
                "completed_at": "2020-06-01T00:28:48.571Z",
                "last_viewed_at": "2020-06-01T00:28:48.571Z",
                "unstructured": "{\"selected_id\":\"a1483918360575\",\"is_correct\":true}"
              },
              "question": {
                "prompt": "Among the four highlighted boxes above, which one seems like the best one to pick in order to look at all its possibilities?",
                "answers": [
                  {
                    "id": "a1483918311450",
                    "text": "B3",
                    "is_correct": false
                  },
                  {
                    "id": "a1483918359016",
                    "text": "B8",
                    "is_correct": false
                  },
                  {
                    "id": "a1483918359833",
                    "text": "F7",
                    "is_correct": false
                  },
                  {
                    "id": "a1483918360575",
                    "text": "G2",
                    "is_correct": true
                  }
                ]
              }
            },
            {
              "id": 247776,
              "key": "ee373581-f973-4a66-9220-c343cc80e16c",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "That's right - we pick `G2` because it has the fewest numbers to try out.",
              "instructor_notes": ""
            },
            {
              "id": 267219,
              "key": "fd6ac9c6-0bcb-4868-a368-6c012808e8e6",
              "title": "Search",
              "semantic_type": "VideoAtom",
              "is_public": true,
              "instructor_notes": "",
              "video": {
                "youtube_id": "omveZu2gRLs",
                "china_cdn_id": "omveZu2gRLs.mp4"
              }
            },
            {
              "id": 259403,
              "key": "626c48f9-b114-447e-8e77-31cd074b30c2",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So it seems that we have a new strategy!\n\n# Strategy 3: Search\n### Pick a box with a minimal number of possible values. Try to solve each of the puzzles obtained by choosing each of these values, recursively.",
              "instructor_notes": ""
            },
            {
              "id": 247782,
              "key": "9d98d24e-e8dc-4a8f-aff1-6e5da995f4d1",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "Before we dive in to code the search function, let's first check our understanding. How would you traverse the following tree using Depth First Search?",
              "instructor_notes": ""
            },
            {
              "id": 247783,
              "key": "db3b0454-62cd-401a-a311-3ba37e84221c",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872dcc6_bfs-quiz/bfs-quiz.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/db3b0454-62cd-401a-a311-3ba37e84221c",
              "caption": "",
              "alt": null,
              "width": 1252,
              "height": 1071,
              "instructor_notes": null
            },
            {
              "id": 259415,
              "key": "8900743a-6905-4daf-8cee-f4c0c54d15d5",
              "title": "DFS Quiz",
              "semantic_type": "ValidatedQuizAtom",
              "is_public": true,
              "instructor_notes": null,
              "user_state": {
                "node_key": "8900743a-6905-4daf-8cee-f4c0c54d15d5",
                "completed_at": "2020-06-01T00:29:41.397Z",
                "last_viewed_at": "2020-06-01T00:29:41.397Z",
                "unstructured": "{\"answer\":\"ABDEHIJCFGKL\",\"is_correct\":true}"
              },
              "question": {
                "prompt": "Traverse the above tree using Depth First Search.\nThe answer should be the string obtained by the labels in the order you've traversed the tree.\nFor example, if your tree has four vertices, A, B, C, D, and you've traversed them in the order B->C->A->D, then the answer should be the string 'BCAD'.",
                "matchers": [
                  {
                    "expression": "ABDEHIJCFGKL"
                  },
                  {
                    "expression": "abdehijcfgkl"
                  }
                ]
              }
            },
            {
              "id": 247785,
              "key": "4684e24a-db26-46d9-885a-439f22fef649",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### DFS Quiz: Solution\n\nAnd here's the answer!",
              "instructor_notes": ""
            },
            {
              "id": 259432,
              "key": "033cabfc-bbfd-4f64-b79a-be531973a3c3",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872ddef_bfs/bfs.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/033cabfc-bbfd-4f64-b79a-be531973a3c3",
              "caption": "ABDEHIJCFGKL",
              "alt": null,
              "width": 1310,
              "height": 1065,
              "instructor_notes": null
            }
          ]
        },
        {
          "id": 245245,
          "key": "d54e395d-8918-44ec-bae7-5e261f51fc9b",
          "title": "Coding the Solution",
          "semantic_type": "Concept",
          "is_public": true,
          "user_state": {
            "node_key": "d54e395d-8918-44ec-bae7-5e261f51fc9b",
            "completed_at": "2020-06-01T00:29:48.498Z",
            "last_viewed_at": "2020-06-09T01:45:36.179Z",
            "unstructured": null
          },
          "resources": null,
          "atoms": [
            {
              "id": 247786,
              "key": "2e667915-0221-4983-bc2b-52cb18a3445d",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "### Coding the Solution\n\nTime to code the final solution!\n\nFinish the code in the function `search`, which will create a tree of possibilities and traverse it using DFS until it finds a solution for the sudoku puzzle.",
              "instructor_notes": ""
            },
            {
              "id": 247787,
              "key": "922124f6-4b36-4d70-96d1-6d23359a2b7e",
              "title": "",
              "semantic_type": "QuizAtom",
              "is_public": true,
              "instructor_notes": "",
              "user_state": {
                "node_key": "922124f6-4b36-4d70-96d1-6d23359a2b7e",
                "completed_at": "2020-06-01T00:40:49.601Z",
                "last_viewed_at": "2020-06-09T01:48:32.350Z",
                "unstructured": "{\"function.py\":\"from utils import *\\n\\ndef search(values):\\n    \\\"\\\"\\\"Apply depth first search to solve Sudoku puzzles in order to solve puzzles\\n    that cannot be solved by repeated reduction alone.\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    Returns\\n    -------\\n    dict or False\\n        The values dictionary with all boxes assigned or False\\n\\n    Notes\\n    -----\\n    You should be able to complete this function by copying your code from the classroom\\n    and extending it to call the naked twins strategy.\\n    \\\"\\\"\\\"\\n    # TODO: Copy your code from the classroom to complete this function\\n    #raise NotImplementedError\\n    values = reduce_puzzle(values)\\n    if values == False:\\n        return False\\n    print(\\\"Pass\\\")\\n    for box in boxes:\\n        if values[box] == '':\\n            return False\\n    solved = [box for box in values.keys() if len(values[box]) == 1]\\n    if len(solved) == 81:\\n        print(\\\"Solved!\\\")\\n        return values\\n    #helper is a list of tuples which has contents like: [('A1',2),('A3',3),...]\\n    #use the sort function to sort it\\n    #fewest is the key with values[key] has the fewest possibilities\\n    helper = [(key, len(values[key])) for key in values.keys()]\\n    helper.sort(key=lambda x: x[1])\\n    fewest = values[helper[0][0]]\\n    # Now use recursion to solve each one of the resulting sudokus, and if one returns a value (not False), return that answer!\\n    for number in fewest:\\n        values[fewest] = number\\n        solved = [box for box in values.keys() if len(values[box]) == 1]\\n        if len(solved)==81:\\n            return search(values)\\n\",\"utils.py\":\"from collections import defaultdict\\n\\nrows = 'ABCDEFGHI'\\ncols = '123456789'\\nboxes = [r + c for r in rows for c in cols]\\nhistory = {}  # history must be declared here so that it exists in the assign_values scope\\n\\n\\ndef extract_units(unitlist, boxes):\\n    \\\"\\\"\\\"Initialize a mapping from box names to the units that the boxes belong to\\n\\n    Parameters\\n    ----------\\n    unitlist(list)\\n        a list containing \\\"units\\\" (rows, columns, diagonals, etc.) of boxes\\n\\n    boxes(list)\\n        a list of strings identifying each box on a sudoku board (e.g., \\\"A1\\\", \\\"C7\\\", etc.)\\n\\n    Returns\\n    -------\\n    dict\\n        a dictionary with a key for each box (string) whose value is a list\\n        containing the units that the box belongs to (i.e., the \\\"member units\\\")\\n    \\\"\\\"\\\"\\n    # the value for keys that aren't in the dictionary are initialized as an empty list\\n    units = defaultdict(list)\\n    for current_box in boxes:\\n        for unit in unitlist:\\n            if current_box in unit:\\n                # defaultdict avoids this raising a KeyError when new keys are added\\n                units[current_box].append(unit)\\n    return units\\n\\n\\ndef extract_peers(units, boxes):\\n    \\\"\\\"\\\"Initialize a mapping from box names to a list of peer boxes (i.e., a flat list\\n    of boxes that are in a unit together with the key box)\\n\\n    Parameters\\n    ----------\\n    units(dict)\\n        a dictionary with a key for each box (string) whose value is a list\\n        containing the units that the box belongs to (i.e., the \\\"member units\\\")\\n\\n    boxes(list)\\n        a list of strings identifying each box on a sudoku board (e.g., \\\"A1\\\", \\\"C7\\\", etc.)\\n\\n    Returns\\n    -------\\n    dict\\n        a dictionary with a key for each box (string) whose value is a set\\n        containing all boxes that are peers of the key box (boxes that are in a unit\\n        together with the key box)\\n    \\\"\\\"\\\"\\n    # the value for keys that aren't in the dictionary are initialized as an empty list\\n    peers = defaultdict(set)  # set avoids duplicates\\n    for key_box in boxes:\\n        for unit in units[key_box]:\\n            for peer_box in unit:\\n                if peer_box != key_box:\\n                    # defaultdict avoids this raising a KeyError when new keys are added\\n                    peers[key_box].add(peer_box)\\n    return peers\\n\\n\\ndef assign_value(values, box, value):\\n    \\\"\\\"\\\"You must use this function to update your values dictionary if you want to\\n    try using the provided visualization tool. This function records each assignment\\n    (in order) for later reconstruction.\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    Returns\\n    -------\\n    dict\\n        The values dictionary with the naked twins eliminated from peers\\n    \\\"\\\"\\\"\\n    # Don't waste memory appending actions that don't actually change any values\\n    if values[box] == value:\\n        return values\\n\\n    prev = values2grid(values)\\n    values[box] = value\\n    if len(value) == 1:\\n        history[values2grid(values)] = (prev, (box, value))\\n    return values\\n\\n\\ndef cross(A, B):\\n    \\\"\\\"\\\"Cross product of elements in A and elements in B \\\"\\\"\\\"\\n    return [x + y for x in A for y in B]\\n\\n\\ndef values2grid(values):\\n    \\\"\\\"\\\"Convert the dictionary board representation to as string\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    Returns\\n    -------\\n    a string representing a sudoku grid.\\n\\n        Ex. '2.............62....1....7...6..8...3...9...7...6..4...4....8....52.............3'\\n    \\\"\\\"\\\"\\n    res = []\\n    for r in rows:\\n        for c in cols:\\n            v = values[r + c]\\n            res.append(v if len(v) == 1 else '.')\\n    return ''.join(res)\\n\\n\\ndef grid2values(grid):\\n    \\\"\\\"\\\"Convert grid into a dict of {square: char} with '123456789' for empties.\\n\\n    Parameters\\n    ----------\\n    grid(string)\\n        a string representing a sudoku grid.\\n\\n        Ex. '2.............62....1....7...6..8...3...9...7...6..4...4....8....52.............3'\\n\\n    Returns\\n    -------\\n        A grid in dictionary form\\n            Keys: The boxes, e.g., 'A1'\\n            Values: The value in each box, e.g., '8'. If the box has no value,\\n            then the value will be '123456789'.\\n    \\\"\\\"\\\"\\n    sudoku_grid = {}\\n    for val, key in zip(grid, boxes):\\n        if val == '.':\\n            sudoku_grid[key] = '123456789'\\n        else:\\n            sudoku_grid[key] = val\\n    return sudoku_grid\\n\\n\\ndef display(values):\\n    \\\"\\\"\\\"Display the values as a 2-D grid.\\n\\n    Parameters\\n    ----------\\n        values(dict): The sudoku in dictionary form\\n    \\\"\\\"\\\"\\n    if values == False:\\n        return\\n    width = 1 + max(len(values[s]) for s in boxes)\\n    line = '+'.join(['-' * (width * 3)] * 3)\\n    for r in rows:\\n        print(''.join(values[r + c].center(width) + ('|' if c in '36' else '')\\n                      for c in cols))\\n        if r in 'CF': print(line)\\n    print()\\n\\n\\ndef reconstruct(values, history):\\n    \\\"\\\"\\\"Returns the solution as a sequence of value assignments\\n\\n    Parameters\\n    ----------\\n    values(dict)\\n        a dictionary of the form {'box_name': '123456789', ...}\\n\\n    history(dict)\\n        a dictionary of the form {key: (key, (box, value))} encoding a linked\\n        list where each element points to the parent and identifies the value\\n        assignment that connects from the parent to the current state\\n\\n    Returns\\n    -------\\n    list\\n        a list of (box, value) assignments that can be applied in order to the\\n        starting Sudoku puzzle to reach the solution\\n    \\\"\\\"\\\"\\n    path = []\\n    prev = values2grid(values)\\n    while prev in history:\\n        prev, step = history[prev]\\n        path.append(step)\\n    return path[::-1]\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    diag_sudoku_grid = '2.............62....1....7...6..8...3...9...7...6..4...4....8....52.............3'\\n    row_units = [cross(r, cols) for r in rows]\\n    column_units = [cross(rows, c) for c in cols]\\n    square_units = [cross(rs, cs) for rs in ('ABC', 'DEF', 'GHI') for cs in ('123', '456', '789')]\\n    unitlist = row_units + column_units + square_units\\n\\n    # TODO: Update the unit list to add the new diagonal units\\n    unitlist = unitlist + [['A1', 'B2', 'C3', 'D4', 'E5', 'F6', 'G7', 'H8', 'I9']] + [\\n        ['I1', 'H2', 'G3', 'F4', 'E5', 'D6', 'C7', 'B8', 'A9']]\\n    print(unitlist)\\n\\n    # Must be called after all units (including diagonals) are added to the unitlist\\n    units = extract_units(unitlist, boxes)\\n    peers = extract_peers(units, boxes)\\n    print(\\\"peers\\\",peers['A1'])\\n    print(\\\"units\\\", units['A1'])\\n\\n\\n\",\"solution.py\":\"from utils import *\\n\\ndef search(values):\\n    \\\"Using depth-first search and propagation, try all possible values.\\\"\\n    # First, reduce the puzzle using the previous function\\n    values = reduce_puzzle(values)\\n    if values is False:\\n        return False ## Failed earlier\\n    if all(len(values[s]) == 1 for s in boxes): \\n        return values ## Solved!\\n    # Choose one of the unfilled squares with the fewest possibilities\\n    n,s = min((len(values[s]), s) for s in boxes if len(values[s]) > 1)\\n    # Now use recurrence to solve each one of the resulting sudokus, and \\n    for value in values[s]:\\n        new_sudoku = values.copy()\\n        new_sudoku[s] = value\\n        attempt = search(new_sudoku)\\n        if attempt:\\n            return attempt\"}"
              },
              "instruction": null,
              "question": {
                "title": "",
                "semantic_type": "ProgrammingQuestion",
                "evaluation_id": "5548291216506880",
                "initial_code_files": [
                  {
                    "text": "from utils import *\n\ndef search(values):\n    \"Using depth-first search and propagation, create a search tree and solve the sudoku.\"\n    # First, reduce the puzzle using the previous function\n    \n    # Choose one of the unfilled squares with the fewest possibilities\n    \n    # Now use recursion to solve each one of the resulting sudokus, and if one returns a value (not False), return that answer!\n\n    # If you're stuck, see the solution.py tab!",
                    "name": "function.py"
                  },
                  {
                    "text": "rows = 'ABCDEFGHI'\ncols = '123456789'\n\ndef cross(a, b):\n    return [s+t for s in a for t in b]\n\nboxes = cross(rows, cols)\n\nrow_units = [cross(r, cols) for r in rows]\ncolumn_units = [cross(rows, c) for c in cols]\nsquare_units = [cross(rs, cs) for rs in ('ABC','DEF','GHI') for cs in ('123','456','789')]\nunitlist = row_units + column_units + square_units\nunits = dict((s, [u for u in unitlist if s in u]) for s in boxes)\npeers = dict((s, set(sum(units[s],[]))-set([s])) for s in boxes)\n\ndef display(values):\n    \"\"\"\n    Display the values as a 2-D grid.\n    Input: The sudoku in dictionary form\n    Output: None\n    \"\"\"\n    width = 1+max(len(values[s]) for s in boxes)\n    line = '+'.join(['-'*(width*3)]*3)\n    for r in rows:\n        print(''.join(values[r+c].center(width)+('|' if c in '36' else '')\n                      for c in cols))\n        if r in 'CF': print(line)\n    return\n\ndef grid_values(grid):\n    \"\"\"\n    Convert grid into a dict of {square: char} with '123456789' for empties.\n    Input: A grid in string form.\n    Output: A grid in dictionary form\n            Keys: The boxes, e.g., 'A1'\n            Values: The value in each box, e.g., '8'. If the box has no value, then the value will be '123456789'.\n    \"\"\"\n    chars = []\n    digits = '123456789'\n    for c in grid:\n        if c in digits:\n            chars.append(c)\n        if c == '.':\n            chars.append(digits)\n    assert len(chars) == 81\n    return dict(zip(boxes, chars))\n    \ndef eliminate(values):\n    \"\"\"\n    Go through all the boxes, and whenever there is a box with a value, eliminate this value from the values of all its peers.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\n    for box in solved_values:\n        digit = values[box]\n        for peer in peers[box]:\n            values[peer] = values[peer].replace(digit,'')\n    return values\n\ndef only_choice(values):\n    \"\"\"\n    Go through all the units, and whenever there is a unit with a value that only fits in one box, assign the value to this box.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    for unit in unitlist:\n        for digit in '123456789':\n            dplaces = [box for box in unit if digit in values[box]]\n            if len(dplaces) == 1:\n                values[dplaces[0]] = digit\n    return values\n\ndef reduce_puzzle(values):\n    \"\"\"\n    Iterate eliminate() and only_choice(). If at some point, there is a box with no available values, return False.\n    If the sudoku is solved, return the sudoku.\n    If after an iteration of both functions, the sudoku remains the same, return the sudoku.\n    Input: A sudoku in dictionary form.\n    Output: The resulting sudoku in dictionary form.\n    \"\"\"\n    solved_values = [box for box in values.keys() if len(values[box]) == 1]\n    stalled = False\n    while not stalled:\n        solved_values_before = len([box for box in values.keys() if len(values[box]) == 1])\n        values = eliminate(values)\n        values = only_choice(values)\n        solved_values_after = len([box for box in values.keys() if len(values[box]) == 1])\n        stalled = solved_values_before == solved_values_after\n        if len([box for box in values.keys() if len(values[box]) == 0]):\n            return False\n    return values",
                    "name": "utils.py"
                  },
                  {
                    "text": "from utils import *\n\ndef search(values):\n    \"Using depth-first search and propagation, try all possible values.\"\n    # First, reduce the puzzle using the previous function\n    values = reduce_puzzle(values)\n    if values is False:\n        return False ## Failed earlier\n    if all(len(values[s]) == 1 for s in boxes): \n        return values ## Solved!\n    # Choose one of the unfilled squares with the fewest possibilities\n    n,s = min((len(values[s]), s) for s in boxes if len(values[s]) > 1)\n    # Now use recurrence to solve each one of the resulting sudokus, and \n    for value in values[s]:\n        new_sudoku = values.copy()\n        new_sudoku[s] = value\n        attempt = search(new_sudoku)\n        if attempt:\n            return attempt",
                    "name": "solution.py"
                  }
                ]
              },
              "answer": null
            },
            {
              "id": 259431,
              "key": "e5aa37d9-0a14-4d2f-a5f8-6ac57fd59c01",
              "title": null,
              "semantic_type": "TextAtom",
              "is_public": true,
              "text": "So, that seemed to do it! You should have got the following solution.",
              "instructor_notes": ""
            },
            {
              "id": 247790,
              "key": "f4f0a47e-bee9-42f5-a006-2848c3c8cc8e",
              "title": null,
              "semantic_type": "ImageAtom",
              "is_public": true,
              "url": "https://video.udacity-data.com/topher/2017/January/5872dfde_hard-solution/hard-solution.png",
              "non_google_url": "https://s3.cn-north-1.amazonaws.com.cn/u-img/f4f0a47e-bee9-42f5-a006-2848c3c8cc8e",
              "caption": "",
              "alt": null,
              "width": 1506,
              "height": 1355,
              "instructor_notes": null
            }
          ]
        }
      ]
    }
  },
  "_deprecated": [
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    },
    {
      "name": "non_google_url",
      "reason": "(2016/8/18) Not sure, ask i18n team for reason"
    }
  ]
}