WEBVTT
Kind: captions
Language: zh-CN

00:00:00.210 --> 00:00:03.710
趁我们还在讲这个话题 我想讲讲局部集束搜索

00:00:03.710 --> 00:00:05.950
因为稍后的课程会涉及到

00:00:05.950 --> 00:00:08.199
好的 你的课堂你做主

00:00:08.199 --> 00:00:11.189
局部集束搜索用的就不止一处位置了

00:00:11.189 --> 00:00:14.219
我把一个位置想成一个粒子 就这么叫吧

00:00:14.220 --> 00:00:16.510
我们要记录 K 个粒子

00:00:16.510 --> 00:00:17.377
观察各时间跨度内

00:00:17.376 --> 00:00:20.705
那些随机生成且与这些粒子相邻的粒子

00:00:20.705 --> 00:00:23.759
保留 k 个最优粒子以备下一次迭代

00:00:23.760 --> 00:00:27.230
如果这些粒子中有哪个达到了目标 那就终止算法

00:00:27.230 --> 00:00:29.949
你或许会觉得这个算法就像随机重启

00:00:29.949 --> 00:00:32.829
但并不是 因为我们会比较

00:00:32.829 --> 00:00:34.059
所有粒子的所有相邻粒子

00:00:34.060 --> 00:00:36.910
各位置之间都有信息流动 对吗？

00:00:36.909 --> 00:00:40.709
而对于普通的随机重启 各迭代之间并不会共享任何信息

00:00:40.710 --> 00:00:41.719
对的

00:00:41.719 --> 00:00:42.820
好的 听着还不错

00:00:42.820 --> 00:00:46.689
但你跟我说过随机集束搜索更有用

00:00:46.689 --> 00:00:48.000
区别在哪里呢？

00:00:48.000 --> 00:00:50.140
随机集束搜索本质不变

00:00:50.140 --> 00:00:53.920
但后继粒子不仅仅会因拟合度而被选中

00:00:53.920 --> 00:00:57.539
选择过程还多了些随机性 从而防止我们卡在局部最大值里

00:00:57.539 --> 00:01:00.500
这思路与模拟退火有些类似

00:01:00.500 --> 00:01:04.159
遗传算法类的算法也是如此

00:01:04.159 --> 00:01:05.547
我们接下来会讨论到.
最新课程跟课件还有一对一辅导请加wx：udacity6

