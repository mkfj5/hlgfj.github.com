WEBVTT
Kind: captions
Language: en

00:00:00.000 --> 00:00:04.945
Now, there's a convention in situation calculus that predicates like 'at',

00:00:04.945 --> 00:00:11.853
we said plane 'p' was at airport 'x' in situation 's'.

00:00:11.853 --> 00:00:14.880
These types of predicates that can vary from one situation to

00:00:14.880 --> 00:00:19.027
another are called fluents from the word fluent,

00:00:19.027 --> 00:00:22.485
having to do with fluidity or change over time.

00:00:22.485 --> 00:00:27.480
And the convention is that they refer to a specific situation and we

00:00:27.480 --> 00:00:33.630
always put that situation argument as the last in the predicate.

00:00:33.630 --> 00:00:37.380
Now, the trickiest part about situation calculus is

00:00:37.380 --> 00:00:41.930
describing what changes and what doesn't change as a result of an action.

00:00:41.930 --> 00:00:45.105
I remember in classical planning we had

00:00:45.105 --> 00:00:50.520
action schemas where we describe one action at a time and said what changed.

00:00:50.520 --> 00:00:55.105
For situation calculus, it turns out to be easier to do it the other way around.

00:00:55.105 --> 00:00:57.090
Instead of writing one action,

00:00:57.090 --> 00:00:59.340
or one schema, or one axiom,

00:00:59.340 --> 00:01:05.700
for each action we do one for each fluent for each predicate that can change.

00:01:05.700 --> 00:01:10.710
And we use a convention called Successor-state axioms and these are

00:01:10.710 --> 00:01:16.230
used to describe what happens in the state that's the successor of executing an action.

00:01:16.230 --> 00:01:22.425
And in general, a Successor-state axiom will have the form of saying for

00:01:22.425 --> 00:01:29.584
all actions and states if it's possible to execute action 'a' in state 's'.

00:01:29.584 --> 00:01:33.103
Then, it will show in general what they look like here,

00:01:33.103 --> 00:01:36.195
then the fluent is true,

00:01:36.195 --> 00:01:43.986
if and only if action 'a' made it true or action 'a' didn't undo it.

00:01:43.986 --> 00:01:48.360
So that is either it wasn't true before and 'a' made it be

00:01:48.360 --> 00:01:53.960
true or it was true before and 'a' didn't do something to stop it being true.

00:01:53.960 --> 00:01:58.467
For example, I show you that Successor-state axiom for the 'In' predicate.

00:01:58.467 --> 00:02:02.305
And just to make it a little bit simpler I'll leave out all that for all quantifiers.

00:02:02.305 --> 00:02:04.680
So wherever you see a variable without a quantifier.

00:02:04.680 --> 00:02:06.373
Assume that there is 'a' for all.

00:02:06.373 --> 00:02:16.350
And what we'll say is it's possible to execute 'a' in situation 's' if that's true, then,

00:02:16.350 --> 00:02:23.850
the 'In' predicate holds between some cargo 'c' and some plane in the state which

00:02:23.850 --> 00:02:31.519
is the result of executing action 'a' in state 's' so that 'In' predicate will hold,

00:02:31.519 --> 00:02:33.005
if and only if,

00:02:33.005 --> 00:02:36.650
either 'a' was a load in action.

00:02:36.650 --> 00:02:41.595
So, if we load the cargo into the plane, then that results,

00:02:41.595 --> 00:02:47.735
the result of executing that action 'a' is that the cargo is in the plane or

00:02:47.735 --> 00:02:54.591
it might be that it was already true that the cargo was in the plane in situation 's'.

00:02:54.591 --> 00:03:00.387
And 'a' is not equal to an unload action.

00:03:00.387 --> 00:03:02.490
So, for all a, and,

00:03:02.490 --> 00:03:06.225
s for which it's possible to execute 'a' in situation 's',

00:03:06.225 --> 00:03:09.390
the 'In' predicate holds if and only if,

00:03:09.390 --> 00:03:12.870
the action was a load or the 'In' predicate used

00:03:12.870 --> 00:03:16.230
to hold in the previous state then the action is not an unload.

