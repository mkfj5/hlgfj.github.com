WEBVTT
Kind: captions
Language: zh-CN

00:00:00.300 --> 00:00:03.169
现在我们来定义一个函数 从而为问题求解

00:00:03.169 --> 00:00:07.570
将函数命名为 Tree.Search 因为该函数将搜索树

00:00:07.570 --> 00:00:09.169
叠加到了状态空间上

00:00:09.169 --> 00:00:10.419
思路如下

00:00:10.419 --> 00:00:13.410
先把边缘初始化为路径

00:00:13.410 --> 00:00:15.880
该路径将只包括初始状态

00:00:15.880 --> 00:00:19.960
然后进入循环 循环会先进行检查

00:00:19.960 --> 00:00:22.060
确认边界是否还有东西

00:00:22.059 --> 00:00:23.250
如果没有 那么搜索失败

00:00:23.250 --> 00:00:24.871
问题没有解

00:00:24.871 --> 00:00:27.957
如果还有 那就进行选择

00:00:27.957 --> 00:00:32.036
Tree. Search 实际上是个函数族 而不是单独的一个算法

00:00:32.036 --> 00:00:35.619
算法的种类取决于我们如何执行 .choice 方法

00:00:35.619 --> 00:00:38.070
至于选择我们稍后再讲

00:00:38.070 --> 00:00:40.799
继续 选择边界的一条路径

00:00:40.799 --> 00:00:43.079
将该路径从边界中取出

00:00:43.079 --> 00:00:45.750
我们在路径末端找到状态

00:00:45.750 --> 00:00:47.990
如果这个状态就是目标 那我们就大功告成了

00:00:47.990 --> 00:00:50.020
我们找到了通往目标的路径

00:00:50.020 --> 00:00:54.080
否则 我们就要扩展这条路径

00:00:54.079 --> 00:00:56.809
我们要搜索这个状态里的所有行动

00:00:56.810 --> 00:01:02.340
然后将行动与状态结果添加到路径中

00:01:02.340 --> 00:01:06.465
从而得到一条新路径 这样一来 新路径就包含了旧路径、行动

00:01:06.465 --> 00:01:08.540
和行动结果

00:01:08.540 --> 00:01:12.579
然后将这些路径都放回边缘里

00:01:12.578 --> 00:01:16.927
现在 Tree. Search 代表的是整个算法族

00:01:16.927 --> 00:01:20.176
而家族相似性就在于所有算法都会搜索边缘、

00:01:20.176 --> 00:01:23.960
弹出元素并判断元素是否能通过目标测试

00:01:23.959 --> 00:01:27.789
而算法的不同则源自这里的选择

00:01:27.790 --> 00:01:31.440
与你决定如何扩展边缘的下一个元素有关

00:01:31.439 --> 00:01:33.810
也就是与你会先搜索哪条路径有关

00:01:33.810 --> 00:01:37.310
我们来讲讲各种算法集

00:01:37.310 --> 00:01:40.150
不同算法集会做出不同的选择 因此先搜索的路径会有所不同

00:01:41.430 --> 00:01:45.450
我想讲的第一个算法叫做宽度优先搜索

00:01:45.450 --> 00:01:49.852
也可以叫最短优先搜索 因为该算法总能

00:01:49.852 --> 00:01:54.183
从边缘里取出一条尚未考虑到的路径

00:01:54.183 --> 00:01:56.182
而且这条路径会是最短的

00:01:56.182 --> 00:01:57.201
算法原理是怎样的呢？

00:01:57.200 --> 00:02:02.619
我们先从长度为零 也就是从初始状态出发的路径开始

00:02:02.620 --> 00:02:08.449
这是边缘唯一的一条路径 所以是最短的 因此我们就选该路径

00:02:08.449 --> 00:02:10.298
将其扩展开来

00:02:10.298 --> 00:02:15.856
应用所有可能行动 将所得的所有路径加进来

00:02:15.856 --> 00:02:20.852
现在我们将这条路径从边缘中取出

00:02:20.852 --> 00:02:23.906
并加入三条新路径

00:02:23.906 --> 00:02:30.099
这条 这条和这条

00:02:30.099 --> 00:02:35.099
现在我们所处的位置在边缘有三条路径

00:02:35.099 --> 00:02:37.629
我们要挑最短的一条

00:02:37.629 --> 00:02:41.930
而这里三条路径长度都相同 都为 1

00:02:41.930 --> 00:02:45.390
所以我们随机挑一条 或者用其它技巧从中挑一条

00:02:46.397 --> 00:02:52.740
假设我们选了这条路径 从这里到锡比乌(Sibiu)(Sibiu)

00:02:52.740 --> 00:02:57.070
现在我想请问

00:02:57.069 --> 00:03:03.539
将这条路径从边缘取出后 下一步要加入什么路径呢？

00:03:03.539 --> 00:03:07.669
请勾选路径末端的城市 告诉我

00:03:07.669 --> 00:03:09.839
要往边缘加入哪条路径？

