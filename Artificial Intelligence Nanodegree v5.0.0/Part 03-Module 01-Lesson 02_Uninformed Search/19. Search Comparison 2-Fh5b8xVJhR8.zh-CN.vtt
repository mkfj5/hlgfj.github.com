WEBVTT
Kind: captions
Language: zh-CN

00:00:00.004 --> 00:00:03.025
既然深度优先搜索不是最优的

00:00:03.025 --> 00:00:05.045
那为什么还有人使用该算法呢？

00:00:05.046 --> 00:00:07.694
这与存储限制有关

00:00:07.694 --> 00:00:12.711
对于这个算法 我讲过它的空间状态含有十分巨大

00:00:12.711 --> 00:00:15.275
甚至是无限的二叉树

00:00:15.275 --> 00:00:19.124
我们会从第一层到第二层 到第三层 一直到第 n 层

00:00:19.123 --> 00:00:21.711
二叉树只会越来越大

00:00:21.711 --> 00:00:26.442
再来想想这些搜索算法涉及的边缘

00:00:26.443 --> 00:00:31.054
我们知道宽度优先搜索的边缘是这样的

00:00:31.053 --> 00:00:35.676
所以等我们到了第 n 层 我们需要存储空间能容纳

00:00:35.676 --> 00:00:40.120
2^n 条路径 这是宽度优先搜索的情况

00:00:40.119 --> 00:00:44.149
而最小代价搜索的边缘则更复杂些

00:00:44.149 --> 00:00:48.460
它要处理的代价边缘轮廓大概像这样

00:00:48.460 --> 00:00:51.258
但总节点数和宽度优先搜索的差不多

00:00:51.258 --> 00:00:54.835
但是深度优先搜索则不同 随着我们逐渐深入树的深层

00:00:54.835 --> 00:00:58.423
我们会沿着这个分支走 然后回到上面

00:00:58.423 --> 00:01:02.838
但不管怎么样 边缘只会有 n 个节点

00:01:02.838 --> 00:01:05.459
而不是 2^n 个节点

00:01:05.459 --> 00:01:08.841
所以深度优先搜索能节省很多空间

00:01:08.840 --> 00:01:12.621
当然 如果我们仍要记录已探索集

00:01:12.621 --> 00:01:15.370
那节省的空间就没那么多了

00:01:15.370 --> 00:01:17.439
但如果没有已探索集

00:01:17.439 --> 00:01:21.902
从空间节省的角度来看 深度优先搜索有着极强的优势

00:01:21.903 --> 00:01:25.537
算法还有一个属性需要考虑

00:01:25.537 --> 00:01:26.770
那就是完备性

00:01:26.769 --> 00:01:31.144
也就是说 如果某处有个目标 算法能否将其找出来？

00:01:31.144 --> 00:01:34.985
我们不假设树很大了 我们假设树是无穷大的

00:01:34.986 --> 00:01:40.120
假设在树的深处藏着一些目标

00:01:40.120 --> 00:01:44.160
请问这些算法都具完备性吗？

00:01:44.159 --> 00:01:48.429
也就是说 它们都能找到通往目标的路径吗？

00:01:48.430 --> 00:01:50.653
请勾选复选框

00:01:50.653 --> 00:01:55.590
选出从这个定义看来 你觉得具完备性的算法

