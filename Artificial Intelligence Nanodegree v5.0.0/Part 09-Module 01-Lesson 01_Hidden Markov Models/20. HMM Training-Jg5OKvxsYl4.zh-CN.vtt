WEBVTT
Kind: captions
Language: zh-CN

00:00:00.370 --> 00:00:04.580
我们开始这节课时 经过检验创建了模型

00:00:04.580 --> 00:00:07.740
然而大多数时候 我们想让训练数据本身

00:00:07.740 --> 00:00:12.609
使用隐马尔可夫模型进行手势识别 我想识别至少每个手势包含 12 个例子

00:00:12.609 --> 00:00:16.629
最少的有 5 个例子

00:00:16.629 --> 00:00:19.882
— 为了说明目的 我们使用手势 I 数据的

00:00:19.882 --> 00:00:20.561
3 个例子

00:00:20.562 --> 00:00:24.769
即使这不是最好的特征 我们还是使用 Δy

00:00:24.768 --> 00:00:28.727
进行训练 第一个例子最长 包括 16 个数据点

00:00:28.728 --> 00:00:32.548
— 我看到接下来的例子很短 只包括 5 个数据点

00:00:32.548 --> 00:00:35.439
最后一个包括 14 个时间帧

00:00:35.439 --> 00:00:39.839
我们再次使用从左向右拓扑图的三个状态 表示隐马尔可夫模型

00:00:39.840 --> 00:00:41.440
在这些例子中

00:00:41.439 --> 00:00:44.289
我们怎样分辨哪个数据与哪个状态匹配呢？

00:00:44.289 --> 00:00:48.299
— 我们假设三个状态帧数相同

00:00:48.299 --> 00:00:50.750
我大体把这些例子各分成三份

00:00:50.750 --> 00:00:53.100
在三分之一的地方画上分界线

00:00:53.100 --> 00:00:56.630
— 一般来说我们这个例子长度是 12 帧

00:00:56.630 --> 00:01:01.040
所以这表明每个状态包括 4 个数据点

00:01:01.039 --> 00:01:01.351
— 没错

00:01:01.351 --> 00:01:05.420
这表明这个状态的转移概率是 1/4

00:01:05.421 --> 00:01:09.108
— 既然各状态的转移概率总和为 1

00:01:09.108 --> 00:01:12.500
自转换为 3/4

00:01:12.500 --> 00:01:14.549
— 既然已经调整了转移概率

00:01:14.549 --> 00:01:16.959
我们要计算输出概率

00:01:16.959 --> 00:01:20.250
— 为了简化 我们再次使用高斯分布

00:01:20.250 --> 00:01:26.680
在第一个状态中 我们从第一个样本中得到 1 3 7 9 7

00:01:26.680 --> 00:01:33.649
第二个样本中是 2 和 10 在这个样本中是 1 3 7 8 7

00:01:33.649 --> 00:01:36.454
这些数的平均数约为 5.4

00:01:36.453 --> 00:01:40.716
标准差是 稍等一下

00:01:40.716 --> 00:01:45.334
我通过 Octave 语言计算得到约 3.1

00:01:45.334 --> 00:01:49.869
我们在第一个状态下面这样绘制 作为输出概率

00:01:49.870 --> 00:01:52.480
— 既然你已经掌握了 可以完成其他状态吗？

00:01:52.480 --> 00:01:55.004
我们计算第二个状态的平均值

00:01:55.004 --> 00:01:58.590
约为 -0.6 标准差是 3.1

00:01:58.590 --> 00:02:04.249
最后一个状态平均值是 -5 标准差是 2.6

00:02:04.248 --> 00:02:06.171
— 我们也来计算出这些概率

00:02:06.171 --> 00:02:10.682
— 现在我们要迭代这个过程

00:02:10.682 --> 00:02:12.280
与期望最大化非常相似

00:02:12.280 --> 00:02:14.669
— 一般说来我们重置转移概率

00:02:14.669 --> 00:02:17.469
根据对正确转移概率的假设

00:02:17.469 --> 00:02:19.870
计算输出概率

00:02:19.870 --> 00:02:22.560
然后我们要假设输出概率是正确的

00:02:22.560 --> 00:02:24.890
然后回去调整转移概率

00:02:24.889 --> 00:02:26.699
如此往复 直到我们收敛到一点

00:02:26.699 --> 00:02:30.019
— 我们下一步是观察如果移动状态之间的分界线

00:02:30.020 --> 00:02:34.100
会不会更好地解释数据

00:02:34.099 --> 00:02:37.799
一般来说 我们要观察是否得到更小方差的高斯分布

00:02:37.800 --> 00:02:38.100
— 好

00:02:38.099 --> 00:02:42.409
很有趣 我们首先看第一个例子的第一个分界线

00:02:42.409 --> 00:02:45.370
显然 5 更加接近平均值 5.4

00:02:45.370 --> 00:02:47.469
分界线应该向右移动

00:02:47.469 --> 00:02:50.199
— 不过 2 最好放在第二个状态中

00:02:50.199 --> 00:02:51.819
— 如何体现出来呢？

00:02:51.819 --> 00:02:55.000
— 2 到第一个状态均值 3.4

00:02:55.000 --> 00:02:59.129
即 3.4 除以 3.1 标准差的距离较远

00:02:59.129 --> 00:03:02.514
换句话说 2 到第一个状态标准差的距离

00:03:02.514 --> 00:03:04.194
超过 1

00:03:04.194 --> 00:03:04.734
— 好

00:03:04.735 --> 00:03:09.370
— 不过第二个状态的均值是 -0.6

00:03:09.370 --> 00:03:13.664
2 到第二个状态均值的距离只有 2.6

00:03:13.664 --> 00:03:19.151
或者 2.6 除以 3.1 标准差的距离

00:03:19.151 --> 00:03:22.609
— 与标准差的距离小于 1

00:03:22.610 --> 00:03:24.600
所以 2 应该放在第二个状态中

00:03:24.599 --> 00:03:25.419
— 目前为止

00:03:25.419 --> 00:03:26.669
— 你指的是什么呢？

00:03:26.669 --> 00:03:30.159
— 目前为止我们完成这个迭代 这个状态的均值和标准差

00:03:30.159 --> 00:03:31.924
会发生变化

00:03:31.925 --> 00:03:34.960
2 会在下一轮移动到第一个状态中

00:03:34.960 --> 00:03:38.409
— 好 但是这次迭代多少个分界线会发生变化呢？

00:03:38.409 --> 00:03:39.789
— 我们来看一下

00:03:39.789 --> 00:03:42.829
我认为 -1 不能移动到第二个状态

00:03:42.830 --> 00:03:48.440
— 但是第二个例子中 -7 更加靠近第三个状态的均值 -5

00:03:48.439 --> 00:03:51.229
— 没错 我们要移动分界线

00:03:51.229 --> 00:03:52.730
— 我们是不是应该更新方差中的均值呢？

00:03:52.730 --> 00:03:56.180
— 最好先观察剩余分界线

00:03:56.180 --> 00:03:59.450
最后一个例子中 看起来我们要移动许多东西

00:03:59.449 --> 00:04:03.129
— 没错 3 应该从第二个状态移动到第一个

00:04:03.129 --> 00:04:07.479
— 显然 -5 应该从第二个状态移动到第三个

00:04:07.479 --> 00:04:09.949
— 第二个状态中的 -3 呢？

00:04:09.949 --> 00:04:12.699
我要快速计算出来这个

00:04:14.629 --> 00:04:19.209
这是第二个状态的标准差 2.4/3.1

00:04:19.209 --> 00:04:22.283
2/2.6 第三个状态均值的标准差

00:04:22.283 --> 00:04:27.610
略微接近第三个状态的均值 虽然没有非常接近

00:04:27.610 --> 00:04:30.389
— 好 我们再次更新分界线

00:04:30.389 --> 00:04:33.439
— 哇塞 这会让我们的数字发生很大变化

00:04:33.439 --> 00:04:36.086
— 没错 我们已经重新计算了一切

00:04:36.086 --> 00:04:39.425
— 一般说来我们现在有 1 2 3 4 5 6 7 8

00:04:39.425 --> 00:04:41.170
9 10 11 12 13 14

00:04:41.170 --> 00:04:44.994
第一个状态中 3 个时间帧中总共 14 个数字

00:04:44.994 --> 00:04:49.221
所以这里我们的转移概率是 1 除以 4.7

00:04:49.221 --> 00:04:56.340
约为 0.21 自循环为 0.79

00:04:56.339 --> 00:04:59.879
— 第二个状态的 3 个时间帧有 7 个数字

00:04:59.879 --> 00:05:04.105
转换概率分别为 0.43 和 0.57

00:05:04.105 --> 00:05:09.641
— 最后一个状态的 3 个时间帧有 14 个数字

00:05:09.641 --> 00:05:17.769
转换概率也是 0.21 这里概率为 0.79

00:05:17.769 --> 00:05:20.810
— 好 我们现在需要更新输出概率的数字

00:05:20.810 --> 00:05:23.290
— 我担心你要这么说

00:05:23.290 --> 00:05:26.975
好 再次依靠 Octava 我得到第一个状态输出概率均值 5.2

00:05:26.975 --> 00:05:31.700
标准差 3.0

00:05:31.699 --> 00:05:33.408
— 来吧 你是拥有计算机的人

00:05:33.408 --> 00:05:35.937
其他的呢？

00:05:35.937 --> 00:05:37.153
— 状态 2 比较简单

00:05:37.153 --> 00:05:39.374
均值是 0 标准差是 1

00:05:39.374 --> 00:05:42.050
— 你那样做是故意的吗？

00:05:42.050 --> 00:05:42.660
— 什么？

00:05:42.660 --> 00:05:45.150
— 利用这个例子 然后得到这样好的数字？

00:05:45.149 --> 00:05:46.500
— 我希望是那么聪明

00:05:46.500 --> 00:05:47.920
— 我有点不抱幻想了

00:05:47.920 --> 00:05:49.990
那么状态 3 的值是多少？

00:05:49.990 --> 00:05:54.360
— 状态 3 的均值是 -5 标准差是 2.5

00:05:54.360 --> 00:05:57.050
— 很棒 现在我们要进行下一轮迭代了

00:05:57.050 --> 00:05:58.720
— 你是说我们还要重复一次？

00:05:58.720 --> 00:06:00.320
— 不要担心 我们已经完成了

00:06:01.879 --> 00:06:07.759
— 正如我预测的那样 在这次对第二个状态迭代过程中

00:06:07.759 --> 00:06:11.849
 2 更加接近第一个状态
— 好 我想你赢了一次

00:06:11.850 --> 00:06:14.580
它只是略微高于第一个状态均值的

00:06:14.579 --> 00:06:15.089
标准差

00:06:15.089 --> 00:06:17.909
第二个状态均值的两个标准差

00:06:17.910 --> 00:06:21.160
— 不过 -1 还是放在第二个状态中

00:06:21.160 --> 00:06:23.180
— 没错 两处都是这样

00:06:23.180 --> 00:06:24.930
— 那我们重新计算一次

00:06:24.930 --> 00:06:26.980
— 现在状态 1 均值是 5

00:06:26.980 --> 00:06:29.090
状态 2 均值是负数

00:06:29.089 --> 00:06:31.639
状态 3 均值保持不变

00:06:31.639 --> 00:06:32.959
— 我认为我们收敛到一点

00:06:32.959 --> 00:06:33.659
我来看一下

00:06:35.269 --> 00:06:39.690
在下一次迭代中没有移动分界线

00:06:39.690 --> 00:06:42.132
也没有 α 发生变化

00:06:42.132 --> 00:06:44.829
— 是不是说我们成功训练了 I 的隐马尔可夫模型

00:06:44.829 --> 00:06:46.334
— 并没有

00:06:46.334 --> 00:06:49.375
从技术角度来说 我们使用 Viterbi 对齐

00:06:49.375 --> 00:06:52.749
对隐马尔可夫模型每个状态的值进行了初始化

00:06:52.749 --> 00:06:55.641
换句话说 对于所有例子中的每个时间帧

00:06:55.641 --> 00:06:58.959
我们已经调整了时间帧的状态

00:06:58.959 --> 00:07:03.734
并且计算了每个状态所有值的平均结果

00:07:03.735 --> 00:07:06.935
— 还有我们希望停留在每个状态中的平均次数

00:07:06.935 --> 00:07:07.245
— 没错

