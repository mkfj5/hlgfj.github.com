WEBVTT
Kind: captions
Language: zh-CN

00:00:00.320 --> 00:00:03.119
我们应该复习如何表示一个隐马尔可夫模型

00:00:03.120 --> 00:00:07.150
— 没错 罗素 (Russell ) 和诺维格 (Norvig) 的书中把他们描述成马尔可夫链

00:00:07.150 --> 00:00:09.679
然后为每个状态增加了输出节点

00:00:09.679 --> 00:00:12.795
这种表现方法在机器学习业界很常见

00:00:12.795 --> 00:00:15.919
其中每个 Xi 表示一个数据帧

00:00:15.919 --> 00:00:20.015
X0 是初始状态 用于保留数据

00:00:20.015 --> 00:00:24.105
X1 代表第一次帧 t 等于 1

00:00:24.105 --> 00:00:27.010
E1 表示当时的输出

00:00:28.074 --> 00:00:33.039
X2 是下一次帧 E2 是当时的输出

00:00:33.039 --> 00:00:36.119
等等 直到我们进行到序列的结尾

00:00:36.119 --> 00:00:39.729
在这种表现手法中 隐马尔可夫模型状态是隐含的

00:00:39.729 --> 00:00:43.879
不过我发现很容易根据它们的状态联想到隐马尔可夫模型

00:00:43.880 --> 00:00:46.140
那么我要脱离这本书

00:00:46.140 --> 00:00:50.250
使用这个讨论中隐马尔可夫模型更具体的表现方法

00:00:50.250 --> 00:00:53.780
首先假设我们有通过时间的信号

00:00:53.780 --> 00:00:55.140
像这个图中这样

00:00:55.140 --> 00:00:58.399
t 等于 0 时 它的值是 -2

00:00:58.399 --> 00:01:04.560
t 等于 10 时 它的值是 -1 t 等于 15 时 它的值是 0

00:01:04.561 --> 00:01:09.374
t 等于 35 时 它的值是 1 t 等于 38 时 它的值是 2

00:01:09.373 --> 00:01:12.569
— 这个图由 4 个不同部分组成

00:01:12.569 --> 00:01:16.909
— 没错 我们要使用 4 个隐马尔可夫模型进行表示

00:01:16.909 --> 00:01:20.019
我们尝试设计一个模型 可以产生这些数据

00:01:20.019 --> 00:01:22.719
在这个例子中 我们使用从左到右的隐马尔可夫模型

00:01:22.719 --> 00:01:27.340
说明我们一旦离开之前的状态 就无法回到之前状态

00:01:27.340 --> 00:01:31.409
这些循环称为自转换 表明模型可以在

00:01:31.409 --> 00:01:33.979
多个时间帧中维持相同状态

00:01:33.980 --> 00:01:36.810
— 接下来我们要计算发射概率

00:01:36.810 --> 00:01:38.990
— 我喜欢称它们是 α 概率

00:01:38.989 --> 00:01:40.799
但这只是它们不同的名字而已

00:01:40.799 --> 00:01:45.030
它表示我们在给定的状态中 哪些值是容许的

00:01:45.030 --> 00:01:47.030
— 这有些更加微妙 对吧？

00:01:47.030 --> 00:01:49.340
由于输出分布是密度

00:01:49.340 --> 00:01:51.170
这些不是真正的概率

00:01:51.170 --> 00:01:53.350
— 这是我们讨论中方便的假定

00:01:53.349 --> 00:01:54.890
所以我会保留它

00:01:54.890 --> 00:01:57.829
在这个例子中 创建输出概率很简单

00:01:57.829 --> 00:02:01.579
图表的第一部分是从 -2 到 -1

00:02:01.579 --> 00:02:03.466
— 所有值得到同等体现

00:02:03.466 --> 00:02:05.739
所以我们只使用一个脉冲分布

00:02:05.739 --> 00:02:06.201
— 非常棒

00:02:06.201 --> 00:02:10.879
在状态 2 中 上面的分布是像是从 -1 到 0 到脉冲

00:02:10.879 --> 00:02:16.349
— 在状态 3 中 我们有个从 0 到 1 的脉冲 在状态 4 中是从 1 到 2 的脉冲

00:02:16.349 --> 00:02:20.219
— 现在我们需要计算转移概率的值

00:02:20.219 --> 00:02:22.550
我们再看一下图表的第一部分

00:02:22.550 --> 00:02:25.439
我们在图表的第一部分中花费 10 帧

00:02:25.439 --> 00:02:28.060
然后转换到图表的第二部分

00:02:28.060 --> 00:02:30.909
那么我们想在这里赋予合适的概率

00:02:30.909 --> 00:02:32.689
这里避开了状态 1

00:02:32.689 --> 00:02:36.329
— 这里不再是 1 我们赋予概率 0.1

00:02:36.330 --> 00:02:40.400
我们希望停留在这个状态 10 帧

00:02:40.400 --> 00:02:44.652
— 既然一个状态所有概率总和为 1 我们只剩下

00:02:44.651 --> 00:02:48.989
自转换概率 我们知道这是 0.9

00:02:48.990 --> 00:02:52.198
— 如果我们想知道停留在既定状态的时间帧

00:02:52.198 --> 00:02:54.020
这里有个小技巧

00:02:54.020 --> 00:02:55.159
我们可以只使用公式

00:02:55.159 --> 00:02:59.789
1 除以 1 减去自转换概率 即 1/(1-p) 进行计算

00:02:59.789 --> 00:03:00.530
— 谢谢 因为某些原因

00:03:00.530 --> 00:03:04.140
我在使用更复杂的隐马尔可夫模型时 其中包含大量状态变化

00:03:04.139 --> 00:03:08.039
忘记使用这个技巧

00:03:08.039 --> 00:03:12.859
— 我们可以对每个状态继续这个过程 状态 2 包括 5 个时间帧

00:03:12.860 --> 00:03:16.900
我们得到这个输出概率是五分之一 即 0.2

00:03:16.900 --> 00:03:19.007
这个是五分之四 即 0.8

00:03:19.007 --> 00:03:23.868
状态 3 包括 20 个时间帧 所以这里得到二十分之一

00:03:23.868 --> 00:03:26.580
即 0.05 这里是 0.95

00:03:26.580 --> 00:03:30.299
模型中的最后一个转换是三分之一 即 0.33

00:03:30.299 --> 00:03:32.790
这个框的转变是 0.67

00:03:32.789 --> 00:03:37.138
— 等一下 我意识到一件事 你说过我可以

00:03:37.138 --> 00:03:40.415
使用公式 1/(1-p)

00:03:40.415 --> 00:03:44.169
计算状态中的帧数

00:03:44.169 --> 00:03:50.449
但是如果我设置概率为 0 计算 1/(1-0) 等于 1

00:03:50.449 --> 00:03:54.019
这意味着我从状态中得到至少 1 个输出

00:03:54.020 --> 00:03:57.995
— 不过那是对的 我们一旦从之前的状态进入这个状态 得到输出

00:03:57.995 --> 00:04:00.094
然后转移到下一个状态

00:04:00.094 --> 00:04:03.574
— 好 这向我解释了其他事情

00:04:03.574 --> 00:04:08.554
许多手册和工具包在每个模型的开头提出了虚拟状态

00:04:08.555 --> 00:04:11.780
我想可以清晰展现进入第一个状态

00:04:11.780 --> 00:04:14.039
实际上这让我想到另一点

00:04:14.039 --> 00:04:18.039
当我处于更加形式化时 我把箭头指向第一个状态

00:04:18.040 --> 00:04:20.660
如果我们进入相同概率的多个不同位置

00:04:20.660 --> 00:04:24.490
我把这些箭头指向每个潜在的输入点

00:04:24.490 --> 00:04:26.990
如果输入点有不同的概率

00:04:26.990 --> 00:04:28.730
我会把它们写在这些箭头上

00:04:28.730 --> 00:04:30.550
— 我们之后还会学习更多细节

00:04:30.550 --> 00:04:33.350
不过我们已经说明了通过检查创建隐马尔可夫模型

00:04:33.350 --> 00:04:35.960
表现特定信号需要做什么

00:04:35.959 --> 00:04:39.439
— 实际上我们需要有想要模拟的大量信号示例

00:04:39.439 --> 00:04:42.139
我们会创建模型 包含所有不同的例子

00:04:42.139 --> 00:04:46.539
平衡泛化和过度拟合

00:04:46.540 --> 00:04:48.050
不过这是后面的内容

00:04:48.050 --> 00:04:52.319
现在我们会假设通过创建隐马尔可夫模型

00:04:52.319 --> 00:04:55.829
实际上这种技巧在检查问题第一关时

00:04:55.829 --> 00:04:57.519
非常强大

00:04:57.519 --> 00:04:59.719
— 我们用来解决实际问题会怎么样？

00:04:59.720 --> 00:05:00.620
— 听起来是不错的想法

