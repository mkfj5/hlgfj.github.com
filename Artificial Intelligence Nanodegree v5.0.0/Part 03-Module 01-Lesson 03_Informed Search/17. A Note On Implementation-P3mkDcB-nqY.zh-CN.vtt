WEBVTT
Kind: captions
Language: zh-CN

00:00:00.390 --> 00:00:05.734
我们在描述算法时谈到了状态空间里的路径

00:00:05.734 --> 00:00:10.208
现在我想从计算机算法的角度 再稍微讲讲

00:00:10.208 --> 00:00:11.000
如何实现的问题

00:00:12.599 --> 00:00:17.170
虽然我们谈了路径 但我们想用某种方式来实现算法

00:00:17.170 --> 00:00:20.160
而说到实现 我们就得说说节点

00:00:20.160 --> 00:00:24.620
节点是一种数据结构 有四种域

00:00:24.620 --> 00:00:29.469
状态域指路径末端的状态

00:00:29.469 --> 00:00:31.739
行动指到达末端所需的行动

00:00:32.899 --> 00:00:38.589
代价指总代价 父节点则是指向其它节点的指针

00:00:40.960 --> 00:00:45.304
在此处 这个拥有状态 S 的节点

00:00:45.304 --> 00:00:51.884
有一个父节点 指向拥有状态 A 的节点

00:00:51.884 --> 00:00:56.496
而状态 A 的节点也有一个父指针 为 Ø

00:00:56.496 --> 00:01:01.546
所以这一系列前后连接的节点就代表了路径

00:01:01.546 --> 00:01:05.783
词组 “路径” 表示的是抽象概念

00:01:05.784 --> 00:01:08.725
词组 “节点” 则表示计算机内存里的数据结构

00:01:08.725 --> 00:01:12.221
不过 你也可以把这两个术语看作是同义词

00:01:12.221 --> 00:01:14.805
因为它们一一对应

00:01:16.040 --> 00:01:19.320
处理节点主要涉及两种数据结构

00:01:19.319 --> 00:01:23.437
一个是边缘 一个是已探索列表

00:01:23.438 --> 00:01:26.317
我们来讲怎么实现这两者

00:01:26.317 --> 00:01:31.212
在边缘 我们要进行的操作是从边缘取出最佳元素

00:01:31.212 --> 00:01:33.817
然后添加新元素

00:01:33.817 --> 00:01:38.807
也就意味着 我们要将边缘作为优先队列来实现

00:01:38.808 --> 00:01:42.107
这个队列知道如何以恰当的顺序来记录最佳元素

00:01:42.106 --> 00:01:46.433
但我们还要额外进行成员检测操作

00:01:46.433 --> 00:01:49.420
新元素是否在边缘上呢？

00:01:49.420 --> 00:01:52.549
因此我们要以集合来表示检测

00:01:52.549 --> 00:01:54.769
而集合可用树或散列表来创建

00:01:55.890 --> 00:01:59.329
因此 实际上最高效的搜索实现

00:01:59.329 --> 00:02:01.010
会同时涉及这两种表示法

00:02:02.269 --> 00:02:05.469
已探索集则简单些

00:02:05.469 --> 00:02:09.069
我们只需要添加新成员

00:02:09.069 --> 00:02:10.180
进行成员检测即可

00:02:10.180 --> 00:02:13.290
所以用一个集合来表示即可

00:02:13.289 --> 00:02:15.729
而这个集合也可以用散列表或树来创建

