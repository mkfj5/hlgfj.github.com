WEBVTT
Kind: captions
Language: zh-CN

00:00:00.340 --> 00:00:03.130
现在我们来创建人工智能

00:00:03.130 --> 00:00:07.401
让其独立地为这类问题求解

00:00:07.402 --> 00:00:11.792
你可以看到搜索算法很擅长

00:00:11.792 --> 00:00:14.253
寻找这类问题的解

00:00:14.253 --> 00:00:18.361
但你可能会抱怨 为了让搜索算法生效

00:00:18.361 --> 00:00:21.103
我们得为算法提供启发式函数

00:00:21.103 --> 00:00:23.792
而启发式函数是来自外界的

00:00:23.792 --> 00:00:27.568
你可能会想 这所谓的智能

00:00:27.568 --> 00:00:28.867
不外乎是沾了好的启发式函数的光

00:00:28.867 --> 00:00:33.100
因此 借助了给定启发式函数的问题求解程序

00:00:33.100 --> 00:00:34.750
根本不能称为智能

00:00:34.750 --> 00:00:38.953
那我们来想想智能可以源自哪里

00:00:38.953 --> 00:00:42.870
想想我们能否自动生成优秀的启发式函数

00:00:42.869 --> 00:00:47.047
我要大致描述下这么个程序

00:00:47.048 --> 00:00:50.178
它能根据问题描述来自动生成优秀的启发式函数

00:00:50.177 --> 00:00:54.311
假设程序得到的问题描述是

00:00:54.311 --> 00:00:59.134
滑块类推盘游戏 游戏中

00:00:59.134 --> 00:01:03.979
如果 A 和 B 相邻 且 B 是空格 那么滑块就可以从 A 移动到 B

00:01:03.979 --> 00:01:10.349
现在假设我们要放松这一限制 把 B 是空格这一条去掉

00:01:10.349 --> 00:01:15.750
那规则就变成了 如果 A 与 B 相邻 那滑块就可以从 A 移动到 B

00:01:15.750 --> 00:01:20.418
这就和启发式函数 h2 一样了 因为滑块

00:01:20.418 --> 00:01:23.439
可以移动到任意相邻位置上

00:01:23.439 --> 00:01:28.149
现在我们把另一部分规则也去掉

00:01:28.150 --> 00:01:32.761
所以规则变成了滑块可以从任意 A 位置移动到任意 B 位置

00:01:32.760 --> 00:01:38.079
没有任何条件限制 这就得到了启发式函数 h1

00:01:38.079 --> 00:01:41.606
因此我们发现 两个启发式函数都可以通过

00:01:41.606 --> 00:01:47.400
对问题形式化描述进行简单机械调整来推导出来

00:01:47.400 --> 00:01:51.680
等我们自动生成了这两个候选的启发式函数

00:01:51.680 --> 00:01:55.878
就可以用另一个办法来生成优秀的启发式函数了

00:01:55.878 --> 00:02:02.049
即新启发式函数 h 等于 (h1, h2) 的最大值

00:02:02.049 --> 00:02:06.370
只要 h1 和 h2 可采纳 h 就一定是可采纳的

00:02:06.370 --> 00:02:08.596
因为它也永远不会高估

00:02:08.596 --> 00:02:12.800
而且因为更接近真实数值 所以能保证效果更好

00:02:12.800 --> 00:02:17.269
像这样结合多个启发式函数 唯一的问题就在于

00:02:17.269 --> 00:02:20.373
计算启发式函数会有所消耗

00:02:20.372 --> 00:02:24.929
就算我们得以拓展更少路径 计算所耗费的时间也可能更长

00:02:24.930 --> 00:02:29.129
像这样去除部分规则的操作叫做生成松弛问题

00:02:29.129 --> 00:02:33.796
我们所做的就是取原始问题 这个时候滑块很难移动

00:02:33.796 --> 00:02:38.560
然后放宽一些限制 从而简化该问题

00:02:38.560 --> 00:02:42.710
往状态中添加新连接也体现了这一点

00:02:42.710 --> 00:02:47.586
假设状态空间原本只有几个连接

00:02:47.586 --> 00:02:51.092
而放宽问题限制 就相当于我们

00:02:51.092 --> 00:02:55.320
添加了新的算子 能以新方式在状态空间中移动

00:02:55.319 --> 00:02:58.939
所以添加新算子只会简化问题

00:02:58.939 --> 00:03:02.409
而永远不会高估问题 因此是可采纳的

