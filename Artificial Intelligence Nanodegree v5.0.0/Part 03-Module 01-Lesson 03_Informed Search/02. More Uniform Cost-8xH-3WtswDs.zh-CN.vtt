WEBVTT
Kind: captions
Language: zh-CN

00:00:00.400 --> 00:00:04.990
我们来进一步了解一致代价搜索的原理

00:00:04.990 --> 00:00:06.169
先从初始状态开始

00:00:07.889 --> 00:00:13.259
从该状态开始拓展 观察不同的路径

00:00:13.259 --> 00:00:16.759
最后的效果就是

00:00:16.760 --> 00:00:20.410
我们按拓扑地图那样的轮廓进行了拓展

00:00:20.410 --> 00:00:23.748
也就是先扩展到一定的距离

00:00:23.748 --> 00:00:27.747
然后拓展得更远些 之后再远些

00:00:27.748 --> 00:00:29.850
到了某个时候 我们就会找到目标

00:00:29.850 --> 00:00:32.240
假设目标在这里

00:00:32.240 --> 00:00:36.630
现在我们找到了一条从初始状态出发、通往该目标的路径

00:00:36.630 --> 00:00:40.593
但注意搜索并没有直接指向目标

00:00:40.593 --> 00:00:44.323
而是在空间里向四面八方拓展

00:00:44.323 --> 00:00:48.497
根据目标所处的位置

00:00:48.497 --> 00:00:50.954
预计我们平均需要探索一半的空间才能找出目标

00:00:50.954 --> 00:00:53.335
如果空间不大 那就还好

00:00:53.335 --> 00:00:58.807
但如果空间很大 那我们就没办法很快地找到目标了

00:00:58.807 --> 00:01:01.891
遗憾的是 我们做不了什么

00:01:01.890 --> 00:01:05.063
只凭现在知道的信息 我们做不到更好了

00:01:05.063 --> 00:01:09.096
所以如果我们想改善算法 想更快地找出目标

00:01:09.096 --> 00:01:11.609
我们就需要更多的信息

00:01:11.609 --> 00:01:15.313
而经证明 最有用的搜索信息

00:01:15.313 --> 00:01:20.578
是初始状态与目标之间的预测距离

00:01:20.578 --> 00:01:25.677
假设我们面对的是路径寻找问题

00:01:25.677 --> 00:01:31.590
我们可以向任意方向移动 上下左右均可

00:01:31.590 --> 00:01:34.490
所以我们取

00:01:34.489 --> 00:01:38.429
状态与目标之间的直线距离作为预测值

00:01:38.430 --> 00:01:43.426
我们要试着用这个预测值 以最快的速度找出通往目标的路径

00:01:43.426 --> 00:01:48.888
现在 有个叫贪婪最佳优先搜索的算法就能做到这一点

00:01:48.888 --> 00:01:54.979
它会根据预测值 优先扩展距离目标最近的路径

00:01:54.980 --> 00:01:57.680
所以这个算法的轮廓是怎样的呢？

00:01:58.879 --> 00:02:01.488
我们从这里开始 观察所有相邻状态

00:02:02.536 --> 00:02:06.989
优先扩展那些看起来离目标最近的状态

00:02:06.989 --> 00:02:12.889
所以我们会像这样、这样、这样

00:02:12.889 --> 00:02:19.250
和这样进行拓展 这样我们就能直接朝目标前进了

00:02:19.250 --> 00:02:23.109
所以现在在搜索空间里 我们不朝四面八方搜索了 搜索轮廓也不是圆圈

00:02:23.109 --> 00:02:26.516
我们的搜索会朝目标扩展

00:02:26.515 --> 00:02:29.144
因此 我们能够马上朝目标移动

00:02:29.145 --> 00:02:33.800
但如果中间有障碍的话 情况又不一样了

00:02:33.800 --> 00:02:38.110
假设这个搜索空间里有一个初始状态和一个目标

00:02:38.110 --> 00:02:39.690
中间有一个无法跨越的障碍

00:02:40.770 --> 00:02:45.876
贪婪最佳优先搜索一开始会像之前一样扩展

00:02:45.876 --> 00:02:48.262
试着抵达这个目标

00:02:48.262 --> 00:02:51.228
等它到达障碍处 它会怎么做呢？

00:02:51.228 --> 00:02:54.520
它会沿着某一路径继续扩展 慢慢地接近

00:02:54.520 --> 00:02:55.290
目标

00:02:56.340 --> 00:02:59.990
所以它不会考虑折返到这里 这样离目标的距离较远

00:02:59.990 --> 00:03:03.980
而是会沿着这条线继续扩展

00:03:03.979 --> 00:03:07.129
这样就总是能慢慢接近目标

00:03:07.129 --> 00:03:09.310
并在最后找到通往目标的路径了

00:03:10.550 --> 00:03:15.181
所以算法会找出路径 为了找出路径 它会扩展少数 点

00:03:15.181 --> 00:03:19.048
但它能够接受比其它路径长的路径

00:03:19.048 --> 00:03:21.973
如果我们反方向进行拓展

00:03:21.973 --> 00:03:25.780
就会找到一条简单许多也短许多的路径

00:03:25.780 --> 00:03:30.042
只要直接跳过障碍就能直通目标了

00:03:30.042 --> 00:03:34.384
但贪婪最佳优先搜索不会这么做

00:03:34.384 --> 00:03:38.465
因为这么做就得到这里 离目标还有这么远

00:03:38.465 --> 00:03:41.736
所以它会考虑实际上离目标更远的状态

00:03:41.736 --> 00:03:46.229
我们真正想要的算法是要将贪婪搜索的精华

00:03:46.229 --> 00:03:51.186
也就是能在大多数情况下探索少数节点

00:03:51.187 --> 00:03:55.771
和一致代价搜索 也即保证能找到最短路径的算法结合起来

00:03:55.770 --> 00:04:03.769
接下来我们会讲如何实现这一点 我们要用一个叫做 A* 的算法

00:04:03.770 --> 00:04:07.439
[无声音]

