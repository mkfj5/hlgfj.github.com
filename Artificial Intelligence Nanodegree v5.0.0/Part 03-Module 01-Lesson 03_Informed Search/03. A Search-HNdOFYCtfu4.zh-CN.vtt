WEBVTT
Kind: captions
Language: zh-CN

00:00:00.165 --> 00:00:04.650
A* 搜索总是优先拓展的路径

00:00:04.650 --> 00:00:10.870
函数 f 的值最小 而函数 f 是由 g 和 h 的和定义的

00:00:10.869 --> 00:00:16.140
其中 函数 g (path) 就是路径代价

00:00:16.140 --> 00:00:20.609
函数 h (path) 则等于

00:00:21.730 --> 00:00:26.690
h (state) 的值 也就是路径的最终状态

00:00:26.690 --> 00:00:29.950
也就等于到目标的预测距离

00:00:31.989 --> 00:00:34.439
A* 算法原理示例如下

00:00:34.439 --> 00:00:38.848
假设我们在状态空间里找到这条途经 X 状态的路径

00:00:38.848 --> 00:00:42.648
我们想测量这条路径的值

00:00:42.649 --> 00:00:47.120
由于评价函数 f 就是 g 和 h 的总和 其中 g 为到目前为止的路径代价

00:00:47.119 --> 00:00:51.787
h 为路径

00:00:51.787 --> 00:00:54.328
到达目标还需的预测距离

00:00:54.329 --> 00:00:59.100
现在 最小化 g 能帮我们维持最小路径距离

00:00:59.100 --> 00:01:03.850
最小化 h 则能帮我们持续聚焦于寻找目标

00:01:03.850 --> 00:01:07.840
二者之和就是我们能找到的最佳搜索策略

00:01:07.840 --> 00:01:10.900
之所以说最佳 是因为它在寻找最短路径的同时

00:01:10.900 --> 00:01:13.400
还会尽可能少地扩展路径

00:01:14.569 --> 00:01:18.446
这个策略可以叫做总路径最佳预测代价优先

00:01:18.447 --> 00:01:20.355
但通常我们称其为 A*

00:01:20.355 --> 00:01:24.469
现在我们回到罗马尼亚 应用 A* 算法看看

00:01:24.469 --> 00:01:25.980
我们要用一个启发式

00:01:25.980 --> 00:01:29.960
也即某状态与目标之间的直线距离

00:01:29.959 --> 00:01:32.399
而目标仍是布加勒斯特

00:01:32.400 --> 00:01:34.520
而从布加勒斯特到布加勒斯特的距离当然是 0 了

00:01:35.819 --> 00:01:36.089
至于

00:01:36.090 --> 00:01:40.370
其它状态 我将它们的直线距离用红字写出来了

00:01:40.370 --> 00:01:42.079
就像这样的直线

00:01:43.230 --> 00:01:47.719
不过我得说 这些我用直线画出的道路

00:01:47.719 --> 00:01:49.989
实际上都会有某种程度的弯曲

00:01:49.989 --> 00:01:52.697
所以道路实际距离

00:01:52.697 --> 00:01:55.019
会比直线距离长

00:01:55.019 --> 00:01:59.949
现在我们像之前一样 先将阿拉德(Arad)作为初始状态 开始搜索

00:01:59.950 --> 00:02:03.347
扩展阿拉德(Arad) 加入三条路径

00:02:03.347 --> 00:02:08.455
评价函数 f 就是路径长度与预测距离的总和

00:02:08.455 --> 00:02:13.580
其中路径长度为黑字 预测距离则为红字

00:02:13.580 --> 00:02:18.942
所以从这条路径出发的函数值

00:02:18.942 --> 00:02:26.792
会等于 140 加 253 即 393

00:02:26.792 --> 00:02:33.466
而这条路径则为 75 加 374 等于 449

00:02:33.466 --> 00:02:41.009
这条路径则是 118 加 329 等于 447

00:02:41.008 --> 00:02:45.955
现在 请问边缘上的这些路径中

00:02:45.955 --> 00:02:49.789
如果使用 A* 算法 接下来要扩展哪一条？

